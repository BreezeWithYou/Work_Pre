# 游戏引擎相关技术汇总

## 引擎分层总结：

**游戏引擎分层架构总结：**

游戏引擎被设计为分层结构
在引擎的分层结构中，越往上，越灵活；越往下，越稳定

<img src="https://pic4.zhimg.com/80/v2-deae25a2de39da489391cf61e27bf799.png" title="" alt="" data-align="center">

**工具层 Tool Layer：**

对于新手，通过在引擎编辑器中进行简单的GUI操作，即可实现游戏功能（设计关卡、动画等），这一层被称为工具层，也是接触引擎时最直观、最直接交互的层级。

**功能层 Function Layer：**

为了使游戏呈现在屏幕上，需要渲染系统对虚拟世界进行渲染。动画系统将艺术家设计的动作动画在引擎中进行组合、过渡，让游戏人物在游戏动起来。逼真的虚拟世界也离不开物理。游戏中的玩法以及NPC人物，也都离不开脚本、事件、AI系统等。为了实现游戏中的人机交互，还需要与输入、输出设备连接。**总之就是我们能够让这个世界可以被看得见，可以动得起来，而且还可以玩起来。其可以看起来的就是游戏中的各种组件及其方法。**

功能层将使得整个虚拟世界变得栩栩如生：每隔tick时间，分别执行逻辑与绘制--tickLogic与tickRender。tickLogic主要用于模拟世界，包括处理输入输出，计算物理并进行碰撞检测等；tickRender将tickLogic计算的结果（人物位置等）进行绘制。

资源层 Resource layer：

游戏引擎中通常包含大量数据和文件，这些文件通常以不同的形式存在，Photoshop中的psd、3ds Max中的max等数据格式比较复杂,包含大量与引擎无关的数据(如编辑信息)，如psd格式将保存Photoshop中所有的图层，包含通道、参考线、注解和颜色模式等信息。**为了避免在使用资源时频繁调度并减少不必要的内存消耗，在导入资源时进行转换，将不同资源（纹理、模型几何、动画等）都转换为资产文件，即assest文件（.ast）。**

**核心层 core layer：**

工具层、功能层、资源层会频繁调用底层代码，使用容器创建、内存分配、数学库、多线程等底层功能，而核心层能够提供上述功能。

**平台层 Platform Layer：**

游戏需要发布在不同平台上，可能需要使用不同的图形API。此外，用户使用的输入设备、硬件设备可能也完全不同，这都需要平台层进行处理。

## 编程语言相关：

C++ 反射机制

## 碰撞检测

碰撞检测可分为 **Broad Phase** （粗略检测）与 **Narrow Phase** （精细检测） 两个阶段。在 Narrow Phase 中，SAT（Separating Axis Theorem，分离轴定理）碰撞检测算法直观且高效。然而，它只适用于 **凸体** 的碰撞检测。它的原理清晰易懂，即 **若两个物体没有发生碰撞，则总会存在一条直线，能将两个物体分离** 。于是，我们把这条能够隔开两个物体的线称为 **分离轴** 。

**Broad Phased（广泛碰撞检测）**

广泛碰撞检测的作用在于，进行一个粗粒度的剔除，找出大概那些物体可能与那些物体发生碰撞。

**BVH Tree**

**Sort and Sweep（效率更高）**

**Narrow Phased（进处的碰撞检测）**

Basic Shape Intersection Test（基本形状相交检测）

球体与球体的检测

球体与胶囊体检测

Minkowski Difference-based Methods

Separating Axis Theorem（SAT）

## 渲染

### 地形的渲染：

1.最简单的方法是按照alpha值混合在一起。

![](https://pic1.zhimg.com/v2-c39d893392f19b76af9b62bbe10d38f0_r.jpg)

2.引入高度值，通过比较高度值决定如何混合。

![](https://pic4.zhimg.com/v2-5c0fc90d68df68280622987af9e56eab_r.jpg)

### 环镜光照

SSAO

SSAO+

HBAO

GTAO

### 渲染管线

Visibility Buffer 是新的发展方向，把几何信息和材质信息分离开来，先判断哪些mesh可见并存储起来（V-Buffer存储这些几何属性），再根据GO的唯一ID去索引材质信息，最后完成shading 光栅化。

随着大场景、大世界、模型细节要求增高，模型的面片数量越来越多，传统的渲染管线会drawover，对许多不需要被渲染的面片浪费大量算力。并且deferred rendering 查找G-Buffer的速度要慢于Visibility Buffer查找V-Buffer 和 ID。

Visibility Buffer可以支持更多更复杂的材质。

## 管理游戏对象（BVH，八叉树）

包围盒的有很多类型：Sphere、AABB、OBB……

```text
在计算机处理 Sphere 最快其次是 0BB
```

![](E:\各类文件\marktext\image\2023-12-19-19-17-50-image.png)

**构建过程**：BVH的构建开始于将场景中所有对象（或其三维表示的一部分，如三角形）包含在一个大的包围盒中。然后，这个大盒子被递归地分割成更小的盒子，直到每个最终的盒子包含场景中的一个或几个对象。这些盒子及其包含的对象形成了一个树状结构，每个节点代表一个盒子，叶节点直接包含场景对象。

* 轴对齐划分（Axis-Aligned Split）：

  **优点**：简单高效，容易实现。**缺点**：可能不总是产生最优的层次结构，特别是在对象高度不均匀分布的场景中。

* 表面积启发式（Surface Area Heuristic, SAH）：

  **优点**：能够生成更高效的层次结构，减少射线追踪等操作的计算成本。**缺点**：计算成本较高，不适合动态更新频繁的场景。

* 中点划分（Median Split）：**优点**：相对简单，能够保证划分的平衡性。**缺点**：可能不如SAH那样在性能上表现出色，尤其是在对象密度差异大的场景中。

**使用过程**：当进行光线追踪或碰撞检测查询时，算法从根节点开始，逐级检查每个节点的包围盒是否与查询有交集。如果没有交集，就可以忽略该节点下所有的对象，从而避免了对它们的不必要计算。如果有交集，就进一步检查其子节点，直到找到与查询有交集的实际对象。

**BVH 更新**

局部更新或称之为“refitting”是一种更高效的方法，不需要完全重建BVH树。当一个物体移动时，只更新影响到的包围盒，而不是整个树结构。这通常涉及到以下步骤：

- **更新叶节点**：首先更新包含移动物体的叶节点的包围盒。
- **向上遍历**：接着从叶节点向上遍历到根节点，更新所有经过的内部节点的包围盒，使其能够正确包含其所有子节点的新包围盒。

树重平衡 (Rebalancing)

对于某些动态变化，仅仅更新包围盒可能会导致BVH树结构不平衡，从而降低效率。在这种情况下，可能需要对树进行重新平衡。这意味着对树的结构进行调整，以确保树的深度尽可能小，同时包围盒尽可能紧凑。

## 动画

[动画混合算法](https://zhuanlan.zhihu.com/p/367418099?utm_id=0)



[问题详解](https://www.cnblogs.com/shushen/p/5987280.html)

