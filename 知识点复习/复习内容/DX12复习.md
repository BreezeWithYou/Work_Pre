本笔者属于是看过的东西比较杂，在去年看过Opengl之后本打算去实现一个简单的渲染管线，但是当时对VK与DX12也很感兴趣于是便打算学习完DX12之后再用DX12 搭建一个小的渲染管线。但是，说实话DX12太难了，其中的概念和Opengl 来比底层很多，现在主要是来明确一些DX12 中的概念。

# DX12 的渲染流程：

1. 定义一些描述场景的数据，如几何数据，贴图，材质、灯光等信息，以Buffer和Texture的形式上传这些数据到VRAM（显存）；

2. 定义如何绘制模型的着色器（VS，PS，GS，HS，DS等）；

3. 通过Root Signature定义Shader的形参，并使用Pipeline State Object（PSO）完成整个管线的配置（shader及一些固定管线的设定）；

4. 通过各类数据的访问视图（CBV，UAV，SRV，RTV，DSV）规范化数据的访问形式，把其中的一些View绑定给shader作为它们的实参；

5. 调用 CommandList 绘制场景

**在有了这个流程之后便可以对细节进行把握**

## 预先准备

在使用DX 渲染场景之前需要做若干的准备，创建工厂，寻找适配器（Adapter）创建设备，命令相关数据。

**DX工厂**

包括DX工厂，Factory（工厂，实在不愿意叫这个中翻）是 DirectX12 API 的入口点。它们可用于查找适配器，然后可以创建设备和其他重要数据结构。

**适配器（Adapter）**

适配器（其实就是显卡）提供有关给定 DirectX 设备的物理属性的信息。您可以使用它查询当前 GPU 名称、厂商商、内存量等信息。

适配器有：软件和硬件适配器 2 类。基于软件的DirectX实现，可以在没有专用硬件（集显）的情况下使用，你可以使用API遍历下适配器就知道了。

**设备（Device）**

Device允许你创建常用的数据对象，如命令队列、分配器、管道、缓冲区、缓冲区视图、着色器blobs、堆和同步原语等资源，其实所有创建相关操作都是用的Device（和DX11一样）。

**命令相关**

ID3D12CommandQueue (命令队列)

命令队列是DX12中一个中心组件，用于接收和调度执行绘图、计算或复制命令的命令列表。它是与GPU交互的主要接口。应用程序将编译好的命令列表提交到命令队列，然后DX12负责按顺序将其派送给GPU执行。

ID3D12CommandAllocator (命令分配器)

命令分配器是用于为命令列表分配和管理内存的对象。在创建命令列表对象之前，必须先创建一个命令分配器。每个命令列表都需要有一个与其关联的命令分配器。命令分配器不能在同时被多个命令列表使用，除非这些命令列表是按顺序记录命令的，且在重置命令分配器之前不会再次使用。

ID3D12GraphicsCommandList (命令列表)

命令列表是用于记录图形和计算命令的对象。开发者会通过命令列表API向其添加绘图、计算或资源复制命令。完成命令记录后，命令列表将被提交到命令队列中以执行这些命令。命令列表可以被重置和复用，这可以减少资源分配和回收的开销。

ID3D12Fence (命令围栏)

命令围栏用于同步CPU和GPU之间的操作，确保特定的操作完成后才继续执行后续的操作。围栏可以被用来监视命令队列中命令的执行状态，当GPU完成命令列表的执行时，围栏的值会被更新，应用程序可以检查该值以确定何时可以安全地回收或再次使用资源。

## 资源

### 资源本身介绍：

渲染流程的第一条说了，以Buffer和Texture的形式上传这些数据到VRAM（显存）。资源上传的过程是什么样子的呢。

DX12 使用`ID3D12Resource` 作为资源的基类，个人认为这种设计思路原因有是GPU 资源本质上是一块块存储数据的缓冲区，这样可以更贴近底层，并其需要使用者自己去提供资源管理的方法。不管是一块buffer，还是一张texture。用ID3D12Resource来统一表示GPU资源，**注意GPU资源并不直接绑定到渲染流水线上，而是通过名为描述符（Descriptor）的中间对象来绑定（这点到后面会介绍）**。

正如`ID3D12Resource`中定义的方法一样:获取其资源描述符与获取当前资源的GPU 虚拟地址。

```C++
virtual D3D12_RESOURCE_DESC STDMETHODCALLTYPE GetDesc( void) = 0;
virtual D3D12_GPU_VIRTUAL_ADDRESS STDMETHODCALLTYPE GetGPUVirtualAddress( void) = 0;
```

### 资源提交的地方：堆区 Heap

GPU资源都位于ID3D12Heap中，Heap的本质是一段连续的显存块，它通过D3D12_HEAP_TYPE设置特定的属性，常用的有三种。

* **D3D12_HEAP_TYPE_DEFAULT：默认堆(default heap)**，堆里的资源只能GPU访问，如果要从CPU上传资源，需要借助上传堆。

* **D3D12_HEAP_TYPE_UNLOAD: 上传堆(upload heap)**，向上传堆提交的都是CPU上传到GPU的资源。  

* **D3D12_HEAP_READBACK: 回读堆(read-back heap)**， CPU可以从该堆中读取资源。

### 资源分配方法

在内存堆(中分配 GPU 资源有多种不同的方式 

**Committed Resources**

使用该方法创建提交的资源`ID3D12Device::CreateCommittedResource`。此方法创建资源和足够大以容纳资源的隐式堆。资源也映射到堆。

**Placed Resources**

已放置的资源显式放置在堆中的特定偏移量处。在创建放置的资源之前，首先使用该`[ID3D12Device::CreateHeap]`方法创建堆。然后使用该方法在堆内创建放置的资源`[ID3D12Device::CreatePlacedResource]`。

虽然放置的资源可以提供更好的性能，因为堆不需要从全局 GPU 内存中为每个资源分配，但必须正确使用放置的资源。放置的资源为实现各种内存管理技术提供了更多选择。但我们必须提前知道将用于放置资源的堆的大小。

**Reserved Resources**

可以创建比单个堆所能容纳的更大的保留资源。可以使用驻留在物理 GPU 内存中的一个或多个堆来映射（和取消映射）部分保留资源。

使用保留资源，可以使用虚拟内存创建大体积纹理，但只需将体积纹理的驻留空间映射到物理内存。此资源类型提供了在不超出 GPU 内存预算的情况下实现使用稀疏体素八叉树。

描述符

* CPU Descriptors 
  
  * Constant buffer view (CBV) 【用于一般数据提交】  
  
  * Unordered access view (UAV) 【用于CS可写入的纹理】  
  
  * Shader resource view (SRV) 【用于提交给shader的纹理】  
  
  * Samplers 【提交给shader的所使用的纹理采样器】

* GPU Descriptors
  
  * Render Target View (RTV) 【渲染目标纹理】  
  
  * Depth Stencil View (DSV) 【渲染目标深度/模板共享纹理】  
  
  * Index Buffer View (IBV) 【Mesh中的索引数据】  
  
  * Vertex Buffer View (VBV) 【Mesh中的顶点数据】  
  
  * Stream Output View (SOV) 【Stream Output输出数据】

CPU Descriptors

**No Shader Visible的descriptor类型要通过绑定在RootSiganture上传递给shader使用**

GPU Descriptors

**其他的descriptor不通过该流程指定，往往是通过command list直接指定。**

GPU Descriptors 比较好理解，是 Shader 访问资源的一种介质，那 CPU Descriptors 呢？CPU Descriptors 用途究竟是什么 CPU Descriptors 实际上解决的是 GPU 如何利用有限资源的问题，是起到辅助的作用。

GPU Descriptors 会存在分配上限，官方文档中说明每种类型的 Descriptor Heap 上限为 100 万个描述符（描述符大小由硬件指定），显然游戏不可能把所有 Shader 可访问资源都放在 GPU Descriptors 中。所以一个自然想到的方式就是将资源到 CPU 可访问的位置（CPU 描述符堆），资源数据一直在 GPU 中。当渲染需要时再从 CPU 可访问的位置（CPU 描述符堆）把资源的引用调入到 GPU Descriptors，这样 Shader 就可以访问到资源了。

![image-20240309105934901](E:\MeDesktop\blog\DX探秘\assets\image-20240309105934901.png)

#### 描述符存放的地点:描述符堆（Descriptor Heap）

描述符堆实际上就是存放描述符的数组，本质上是存放特定类型描述符的一块内存。

**描述符堆的类型**

描述符堆有以下类型：

* D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV：可以存放CBV, SRV和UAV

* D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER： 存放sampler

* D3D12_DESCRIPTOR_HEAP_TYPE_RTV：存放RTV

* D3D12_DESCRIPTOR_HEAP_TYPE_DSV：存放DSV

### Two:资源绑定

#### Shader参数设置:根签名

根签名类似于 C++ 函数签名，即它定义传递到着色器管道的**参数**。**绑定到管道的值**称为根**参数**。传递给着色器的**参数**可以更改，而无需更改根签名**参数**。

Root Signature 本质上是 Shader 可访问资源的布局结构。在根签名中每个 Shader 可访问的数据项称为 Root Parameter。根签名可以包含任意数量的参数。每个参数可以是以下类型之一

- `D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS`：32 位根常量
- `D3D12_ROOT_PARAMETER_TYPE_CBV`：内联 CBV 描述符
- `D3D12_ROOT_PARAMETER_TYPE_SRV`：内联 SRV 描述符
- `D3D12_ROOT_PARAMETER_TYPE_UAV`：内联UAV 描述符
- `D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE`：描述符表

根参数本质上是一块可以在 GPU 中访问的内存，每个 Draw/Compute 之间修改的根参数都会被驱动或硬件保存一份单独的数据，这被称为根参数的版本控制。所以如果根参数比较大，而每次改动比较小，会造成大部分没有变动的数据冗余保存，增加了硬件开销。有些硬件会比较优化的存储这些改动，减少不变的部分的冗余。另外，硬件为了保证 API 的绘制语义正确，当根参数超出硬件存储的大小时，会溢出到更慢的系统内存或硬件内部的其它更慢的存储机制（溢出访问成本增加），这种情况下如果能将频繁变化的 RP 保存在的根参数溢出范围内，则能极大程度上减少由于溢出访问更慢存储而造成的开销，这也就是 D3D12 建议将频繁变化的根参数尽可能的设置在靠近 根参数堆头部最本质的原因。

#### 根签名参数

常量缓冲区绑定到b寄存器 (b0 – bN)

着色器资源视图（纹理和非常量缓冲区类型）绑定到t寄存器 (t0 – tN)

无序访问视图（可写纹理和缓冲区类型）是绑定到u 个寄存器 (u0 – uN)

32 位根常量

量缓冲区数据可以传递到着色器，而无需使用 32 位常量创建常量缓冲区资源。对于存储在根签名空间中的常量数据，不支持对常量缓冲区数据进行动态索引。例如，以下常量缓冲区定义可以映射到根签名中存储的 32 位常量：

描述符表定义了连续放置在 GPU 可见描述符堆中的多个描述符范围。

### DX12 相对于传统的图形API增加了什么

* 在 Direct3D 12 中，CPU-GPU 同步现在是应用程序的显式责任，不再像 Direct3D 11 中那样由运行时隐式执行。这一事实也意味着 Direct3D 12 不会执行管道危险的自动检查，所以这又是应用程序的责任。

* 使用PSO(PipelineStateObject）快速切换渲染状态 -> 每个指令需要显式地绑定对应地PSO，可以减少上下文切换的消耗。

* 需要手动指定资源的同步，与资源的内存管理

* 提供可控的内存分配堆 ，更精细的内存控制，为（保留资源）虚拟内存提供可能。

# DX12 渲染工作提交

## 命令提交

**OpenGL的渲染上下文：** 在OpenGL中，渲染上下文是一个非常核心的概念。它代表了OpenGL状态机的所有状态。当你在OpenGL中绘制任何东西时，你都是在一个特定的上下文中进行操作，这个上下文保存了所有的状态信息，包括当前激活的着色器、绑定的纹理、开启的功能等。

这种设计意味着，如果你想要在多个线程中使用OpenGL进行渲染，每个线程都需要有自己的渲染上下文，并且在不同线程间共享资源是相对复杂的。

与此相对，DirectX 12在设计时就考虑到了多线程渲染的需求。它去掉了传统的“上下文”概念，引入了如命令列表（Command List）和命令队列（Command Queue）的新概念。在DX12中，你可以在不同的线程中创建命令列表，每个命令列表可以独立记录渲染命令（如绘制调用、资源绑定等）。然后，这些命令列表可以被提交到命令队列中，在GPU上顺序执行。

渲染信息的记录由原来的上下文记录转变为，由命令列表记录。

### 创建命令列表

创建命令列表`CommandList`直接命令列表和捆绑包是通过调用 `ID3D12Device::CreateCommandList` 或 `ID3D12Device4::CreateCommandList1` 创建的。

`ID3D12Device::CreateCommandList` 采用以下参数作为输入：

* `D3D12_COMMAND_LIST_TYPE` 命令列表枚举

`D3D12_COMMAND_LIST_TYPE` 枚举指示正在创建的命令列表的类型。它可以是直接命令列表、捆绑(将一部分api 集合给包装起来，让硬件进行优化性能)、计算命令列表或复制命令列表。

* `ID3D12CommandAllocator`命令分配器

命令分配器允许应用程序管理分配给命令列表的内存。命令分配器是通过调用`CreateCommandAllocator `创建的。创建命令列表时，由`D3D12_COMMAND_LIST_TYPE`指定的分配器的命令列表类型必须与正在创建的命令列表的类型匹配。尽管一个命令分配器可用于创建任意数量的 `GraphicsCommandList` 对象，但给定的分配器一次只能与不超过一个当前记录命令列表相关联。

要回收命令分配器分配的内存，应用程序调用 `ID3D12CommandAllocator::Reset`。这允许分配器重新用于新命令，但不会减少其底层大小。

### 记录命令列表

命令列表创建后处于记录状态，用户可以通过调用 `ID3D12GraphicsCommandList::Reset `来重新使用现有命令列表，这也会使命令列表处于记录状态。与 `ID3D12CommandAllocator::Reset `不同，您可以在命令列表仍在执行时调用 Reset。

典型的模式是提交命令列表，然后立即重置它以将分配的内存重新用于另一个命令列表。注意，一次只有一个与每个命令分配器相关联的命令列表可以处于记录状态。

一旦命令列表处于记录状态，您只需调用 ID3D12GraphicsCommandList 接口的方法即可将命令添加到列表中。其中许多方法都支持 Microsoft Direct3D 11 开发人员所熟悉的常见 Direct3D 功能；其他 API 是 Direct3D 12 的新增功能。

### 命令分配器

命令分配器可以增长但不会收缩 - 应考虑池化和重用分配器以最大限度地提高应用程序的效率。您可以在重置之前将多个列表记录到同一个分配器，前提是一次只有一个列表记录到给定的分配器。您可以将每个列表可视化为拥有分配器的一部分，该分配器指示 ID3D12CommandQueue::ExecuteCommandLists 将执行的内容。

一个简单的分配器池策略应该以大约 numCommandLists * MaxFrameLatency 分配器为目标。例如，如果您记录 6 个列表并允许最多 3 个潜在帧，则您可以合理地预期 18-20 个分配器。更高级的池化策略就不过多的赘述。

来一个官方文档的实例

```C++
void D3D12HelloTriangle::LoadAssets()
{
    // 创建根签名
    {
        CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
        rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

        ComPtr<ID3DBlob> signature;
        ComPtr<ID3DBlob> error;
        ThrowIfFailed(D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &signature, &error));
        ThrowIfFailed(m_device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&m_rootSignature)));
    }

    // 创建管道状态，其中包括编译和加载着色器。
    {
        ComPtr<ID3DBlob> vertexShader;
        ComPtr<ID3DBlob> pixelShader;

#if defined(_DEBUG)
        UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#else
        UINT compileFlags = 0;
#endif
        ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(), nullptr, nullptr, "VSMain", "vs_5_0", compileFlags, 0, &vertexShader, nullptr));
        ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(), nullptr, nullptr, "PSMain", "ps_5_0", compileFlags, 0, &pixelShader, nullptr));

        // 定义顶点输入描述
        D3D12_INPUT_ELEMENT_DESC inputElementDescs[] =
        {
            { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
            { "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }
        };

        // 描述并创建图形管道状态对象（PSO）。
        D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {};
        psoDesc.InputLayout = { inputElementDescs, _countof(inputElementDescs) };
        psoDesc.pRootSignature = m_rootSignature.Get();
        psoDesc.VS = { reinterpret_cast<UINT8*>(vertexShader->GetBufferPointer()), vertexShader->GetBufferSize() };
        psoDesc.PS = { reinterpret_cast<UINT8*>(pixelShader->GetBufferPointer()), pixelShader->GetBufferSize() };
        psoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
        psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
        psoDesc.DepthStencilState.DepthEnable = FALSE;
        psoDesc.DepthStencilState.StencilEnable = FALSE;
        psoDesc.SampleMask = UINT_MAX;
        psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
        psoDesc.NumRenderTargets = 1;
        psoDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
        psoDesc.SampleDesc.Count = 1;
        ThrowIfFailed(m_device->CreateGraphicsPipelineState(&psoDesc, IID_PPV_ARGS(&m_pipelineState)));
    }

    // 创建命令列表。
    ThrowIfFailed(m_device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.Get(), m_pipelineState.Get(), IID_PPV_ARGS(&m_commandList)));

    // 录制状态下创建了命令列表，但是当前尚未记录。所以现在关闭它。
    ThrowIfFailed(m_commandList->Close());

    // 创建顶点缓冲区
    {
        // 定义三角形的几何形状。
        Vertex triangleVertices[] =
        {
            { { 0.0f, 0.25f * m_aspectRatio, 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } },
            { { 0.25f, -0.25f * m_aspectRatio, 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } },
            { { -0.25f, -0.25f * m_aspectRatio, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } }
        };

        const UINT vertexBufferSize = sizeof(triangleVertices);

        // 注意：使用上传堆传输静态数据（如顶点缓冲区）是不可行的
        ThrowIfFailed(m_device->CreateCommittedResource(
            &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
            D3D12_HEAP_FLAG_NONE,
            &CD3DX12_RESOURCE_DESC::Buffer(vertexBufferSize),
            D3D12_RESOURCE_STATE_GENERIC_READ,
            nullptr,
            IID_PPV_ARGS(&m_vertexBuffer)));

        // 将三角形数据复制到顶点缓冲区。
        UINT8* pVertexDataBegin;
        CD3DX12_RANGE readRange(0, 0);        // We do not intend to read from this resource on the CPU.
        ThrowIfFailed(m_vertexBuffer->Map(0, &readRange, reinterpret_cast<void**>(&pVertexDataBegin)));
        memcpy(pVertexDataBegin, triangleVertices, sizeof(triangleVertices));
        m_vertexBuffer->Unmap(0, nullptr);

        // 初始化顶点缓冲区视图。
        m_vertexBufferView.BufferLocation = m_vertexBuffer->GetGPUVirtualAddress();
        m_vertexBufferView.StrideInBytes = sizeof(Vertex);
        m_vertexBufferView.SizeInBytes = vertexBufferSize;
    }

    // 创建同步对象并等待资源上传到 GPU。
    {
        ThrowIfFailed(m_device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&m_fence)));
        m_fenceValue = 1;

        // 创建用于帧同步的事件句柄。
        m_fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
        if (m_fenceEvent == nullptr)
        {
            ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError()));
        }
        // 等待命令列表执行；我们正在重复使用相同的命令
        // 它在我们的主循环中，但现在，我们只想等待设置
        WaitForPreviousFrame();
    }
}
```

### 命令执行模式

在Direct3D 12中，命令提交 “以前版本的立即模式不再存在”的说法，以往的DX11有两种渲染模式：立即模式（Immediate Mode）和 延迟模式（延迟模式并不是主流的）。

**立即模式（Immediate Mode）**：在Direct3D 11及更早版本中，立即模式是主要的渲染模式。在这种模式下，当开发者调用一个绘制命令时，该命令会立即被发送到GPU进行处理。这种模式下，CPU和GPU的交互非常频繁，每个绘制调用都需要CPU的介入，可能会导致CPU成为性能瓶颈。

在Direct3D 12中，这种模式发生了根本性的变化：

- Direct3D 12取消了传统的立即模式渲染上下文，转而全面采用类似于延迟模式的命令列表（Command Lists）和命令队列（Command Queues）的方式。
- 在Direct3D 12中，开发者需要先在命令列表中记录所有渲染命令，然后将这些命令列表提交到命令队列中。GPU会按照命令队列中的顺序执行这些命令。这样做的好处是可以在多个CPU核心上并行生成命令列表，从而更有效地利用多核CPU。

## ID3D12PipelineState 管线状态（PSO）

### PSO 的设计思路：

其背后的想法是 GPU 可以通过一次性设置相关设置（例如混合状态设置）来提高效率。然而，对于当今的图形硬件，不同硬件单元之间存在依赖性。例如，硬件混合状态可能依赖于光栅状态以及混合状态。

### PSO 优化的原理

**先谈一下Opengl 的渲染方式**

OpenGL采用的是一个更传统的状态机模型来处理渲染状态。在OpenGL中，你可以想象有一个全局的状态机，你通过调用不同的函数来更改这个状态机的状态。

OpenGL允许运行时更改几乎任何状态。这意味着状态的依赖性和验证主要发生在运行时，而不是像DX12那样在创建时就确定，因为OpenGL需要在运行时管理和验证这些状态，所以可能会产生一些性能开销。尤其是在状态频繁改变时，可能会影响应用程序的性能。

现代硬件中在不同的硬件单元（Hardware Units）之间存在依赖。例如，硬件 Blend State 也许和渲染状态，光栅化之间存在依赖。Direct3D 12 的 PSO，允许 GPU 在初始化时预处理所有的依赖，这样就能让运行时尽可能的提高效率。

通过这样一个集合，Direct3D 便可以确定所有的状态是都兼容。虽然之前的图形API 的渲染状态是分开配置的，然而这些状态之间可能相互联系的，可能会出现一个状态发生改变，另一个相关的独立状态也发生改变。造成硬件状态的频繁改写，为避免冗余操作。DX12 提出PSO明确整条流水线的状态，并发起绘制调用之后。才正式生成对应的本地指令。

核心点：早期的图形APi允许单独设置这些管道阶段，因此显示驱动程序无法解决管道状态问题，直到状态最终确定（直到绘制时间）。DX12通过将大部分管道状态统一为不可变管道状态对象 (PSO) 。硬件只需将最少量的预计算状态直接复制到硬件寄存器，而不是动态计算硬件状态。通过使用 PSO，绘制调用开销显着减少，并且每帧可以发生更多绘制调用。

Direct3D 12 与 Direct3D 11 编程模型有很大不同。Direct3D 12 让应用程序比以往更接近硬件。

**所有的问题理解部分内容均为笔者的猜想，如有错误希望大佬来指点迷津。**

问题：笔者去如何理解状态之间的依赖？

我用硬件混合状态可能依赖于光栅化状态于混合阶段举例，光栅化状态的作用：决定了哪些像素会被生成（例如，通过剔除模式和填充模式）。混合状态定义了如何将新像素的颜色与帧缓冲区中已存在的像素颜色结合。硬件混合状态需要上述两者，OpenGL的状态机需要动态地修改状态，会引入更多的运行时开销。由于OpenGL不能提前知道某些状态配置并为其在硬件上做优化，但是DX12 的PSO减少了驱动程序的猜测和运行时开销。

### PSO 创建

PSO在DX12 中的类名字叫做`ID3D12PipelineState`，这个对象集合了大量的管线状态信息，为了保持性能，总是将相关的对象都集中在一起，一并送至流水线。

[`ID3D12Device::CreateGraphicsPipelineState `](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate)可以设置的状态包括：

- 所有着色器的字节码，包括顶点、像素、域、外壳和几何着色器。
- 输入顶点格式。
- 原始拓扑类型
- 混合状态、光栅化器状态、深度模板状态。
- 深度模板和渲染目标格式以及渲染目标计数。
- 多重采样参数。
- 流输出缓冲区。
- 根签名。

根签名即为，管线中的全部着色器的参数

## 资源屏障同步资源状态

### 早期的资源管理

在DirectX 11及Opengl 中，资源状态管理是隐式进行的，这意味着大部分状态管理工作是由驱动程序自动完成的。每当应用程序执行一个操作，如绘制调用或资源绑定，驱动程序需要检查所涉及资源的当前状态，并确定是否需要进行状态转换。就和GC一样系统为了安全，牺牲了一部分性能。

### 为什么需要资源屏障

我们通常会通过GPU对某一个资源进行先写入后读这两种操作。然而当GPU的写操作还没有完全执行完毕的时候进行读取就产生资源冒险的现象。DX12中使用资源屏障去管理资源的同步。

在DirectX 12 (DX12) 中，资源屏障（Resource Barriers）确保资源在被不同的命令访问时处于正确的状态。资源屏障确保在资源状态改变之前，所有对该资源的前面的使用都已完成，这对于保证渲染过程中数据的正确性和性能优化非常关键。以下是一些常见的使用资源屏障的情景：

1. **渲染目标（Render Targets）切换**：当一个渲染目标（比如一个纹理）完成写入后，需要被另一个操作读取时，需要插入一个资源屏障来保证所有的写入操作完成后才能开始读取。
2. **纹理更新**：当你更新一个纹理的内容，然后想用它进行渲染或作为着色器的输入，你需要在写入纹理数据和使用这些数据之间插入资源屏障。
3. **深度缓冲区**：在深度缓冲区被用作渲染目标进行深度写入后，如果想将其用作深度纹理进行采样，需要在这两种用途之间设置资源屏障。
4. **Compute Shader和Graphics Pipeline之间的资源共享**：当资源在Compute Shader和Graphics Pipeline之间共享时，通常需要在两者之间插入资源屏障，以确保Compute Shader的修改在Graphics Pipeline访问该资源之前完成。

**DX12 龙书的例子**

后台缓冲区在渲染的开始需要将其由`PRESENT`状态转变为`RENDER_TARGET`状态，在后备缓冲区数据写完之后转为`PRESENT`状态。

```C++
    // Indicate a state transition on the resource usage.
mCommandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(CurrentBackBuffer(),
        D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

......................

mCommandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(CurrentBackBuffer(),
        D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));
```

### Resource barrier（资源屏障）

**Resource barrier 的目的：**

（为了减少总体 CPU 使用率并启用驱动程序多线程和预处理）Direct3D 12 将按资源状态管理的职责从图形驱动程序转移到应用程序。

**Resource barrier 的分类：**

* **转换屏障（Transition Barriers）**：这是最常见的资源屏障类型，用于指示一个资源从一种使用状态转换到另一种。

一个纹理从渲染目标状态（RenderTarget）转换到着色器读取状态（ShaderResource）。通过这种屏障，可以确保在资源状态改变之前，所有前面对该资源的使用都已经完成，从而避免数据冲突。

* **别名屏障（Aliasing Barriers）**：别名屏障用于处理资源在内存中的重叠使用。当两个或多个资源可能占用同一块内存区域时，别名屏障确保一个资源的使用完成后，另一个资源才能开始使用这块内存。这种屏障不涉及资源状态的转换，而是用来通知GPU关于内存使用的改变，以确保资源不会发生冲突。

* **UAV屏障（UAV Barriers）**：无序访问视图（UAV）屏障用于确保对无序访问视图的所有写入都完成后，才能开始后续的读取或写入。这种屏障特别适用于在计算着色器或其他涉及到无序访问操作的场景中，确保数据的一致性和正确性。

### Spilt Barrier (分隔屏障)

具有 `D3D12_RESOURCE_BARRIER_FLAG_BEGIN_ONLY`标志的资源转换屏障开始分割屏障，并且转换屏障被称为待处理。当屏障挂起时，GPU 无法读取或写入（子）资源。可应用于具有挂起屏障的（子）资源的唯一合法转换屏障是具有相同前后状态和 `D3D12_RESOURCE_BARRIER_FLAG_END_ONLY` 标志的屏障，该屏障完成挂起转换。

分割屏障向 GPU 提供提示：状态 A 中的资源稍后将在状态 B 中使用。这使 GPU 可以选择优化转换工作负载，从而可能减少或消除执行停顿。发出仅限结束的屏障可保证所有 GPU 转换工作在进入下一个命令之前完成。

使用分割屏障有助于提高性能，特别是在多引擎场景中或资源在一个或多个命令列表中稀疏地进行读/写转换的情况下。

1. **开始阶段（Transition Begin）**：在这个阶段，资源被标记为正在从一个状态转换到另一个状态，但转换尚未完成。这意味着资源暂时不能用于任何操作，但GPU可以开始处理其他任务。
2. **结束阶段（Transition End）**：这个阶段完成状态转换，资源现在可以在新状态下使用。结束阶段可以在开始阶段之后的任何时间点发生，这为资源管理和命令调度提供了更大的灵活性。

### Resource barrier 的脚本示例：

1. 创建深度模板视图，将其转换为可写状态。

```C++
// 创建深度模板。
{
    CD3DX12_RESOURCE_DESC shadowTextureDesc(
        D3D12_RESOURCE_DIMENSION_TEXTURE2D,
        0,
        static_cast<UINT>(m_viewport.Width), 
        static_cast<UINT>(m_viewport.Height), 
        1,
        1,
        DXGI_FORMAT_D32_FLOAT,
        1, 
        0,
        D3D12_TEXTURE_LAYOUT_UNKNOWN,
        D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL | D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE);

    D3D12_CLEAR_VALUE clearValue;    // 性能提示：在资源创建时告诉运行时所需的明确值。
    clearValue.Format = DXGI_FORMAT_D32_FLOAT;
    clearValue.DepthStencil.Depth = 1.0f;
    clearValue.DepthStencil.Stencil = 0;

    ThrowIfFailed(m_device->CreateCommittedResource(
        &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
        D3D12_HEAP_FLAG_NONE,
        &shadowTextureDesc,
        D3D12_RESOURCE_STATE_DEPTH_WRITE,
        &clearValue,
        IID_PPV_ARGS(&m_depthStencil)));

    // 创建深度模具视图
    m_device->CreateDepthStencilView(m_depthStencil.Get(), nullptr, m_dsvHeap->GetCPUDescriptorHandleForHeapStart());
}
```

2. 创建顶点缓冲区视图，首先将其从公共状态更改为目标，然后从目标更改为通用可读状态。

```c++
// 创建顶点缓冲区。
{
    ThrowIfFailed(m_device->CreateCommittedResource(
        &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
        D3D12_HEAP_FLAG_NONE,
        &CD3DX12_RESOURCE_DESC::Buffer(SampleAssets::VertexDataSize),
        D3D12_RESOURCE_STATE_COPY_DEST,
        nullptr,
        IID_PPV_ARGS(&m_vertexBuffer)));

    {
        ThrowIfFailed(m_device->CreateCommittedResource(
            &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
            D3D12_HEAP_FLAG_NONE,
            &CD3DX12_RESOURCE_DESC::Buffer(SampleAssets::VertexDataSize),
            D3D12_RESOURCE_STATE_GENERIC_READ,
            nullptr,
            IID_PPV_ARGS(&m_vertexBufferUpload)));

        // 将数据复制到上传堆，然后安排复制,从上传堆到顶点缓冲区。
        D3D12_SUBRESOURCE_DATA vertexData = {};
        vertexData.pData = pAssetData + SampleAssets::VertexDataOffset;
        vertexData.RowPitch = SampleAssets::VertexDataSize;
        vertexData.SlicePitch = vertexData.RowPitch;

        PIXBeginEvent(commandList.Get(), 0, L"Copy vertex buffer data to default resource...");

        UpdateSubresources<1>(commandList.Get(), m_vertexBuffer.Get(), m_vertexBufferUpload.Get(), 0, 0, 1, &vertexData);
        commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_vertexBuffer.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER));

        PIXEndEvent(commandList.Get());
    }
```

3. 创建索引缓冲区视图，首先将其从公共状态更改为目标，然后从目标更改为通用可读状态。

```C++
// 创建索引缓冲区。
{
    ThrowIfFailed(m_device->CreateCommittedResource(
        &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
        D3D12_HEAP_FLAG_NONE,
        &CD3DX12_RESOURCE_DESC::Buffer(SampleAssets::IndexDataSize),
        D3D12_RESOURCE_STATE_COPY_DEST,
        nullptr,
        IID_PPV_ARGS(&m_indexBuffer)));

    {
        ThrowIfFailed(m_device->CreateCommittedResource(
            &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
            D3D12_HEAP_FLAG_NONE,
            &CD3DX12_RESOURCE_DESC::Buffer(SampleAssets::IndexDataSize),
            D3D12_RESOURCE_STATE_GENERIC_READ,
            nullptr,
            IID_PPV_ARGS(&m_indexBufferUpload)));

        // Copy data to the upload heap and then schedule a copy 
        // from the upload heap to the index buffer.
        D3D12_SUBRESOURCE_DATA indexData = {};
        indexData.pData = pAssetData + SampleAssets::IndexDataOffset;
        indexData.RowPitch = SampleAssets::IndexDataSize;
        indexData.SlicePitch = indexData.RowPitch;

        PIXBeginEvent(commandList.Get(), 0, L"Copy index buffer data to default resource...");

        UpdateSubresources<1>(commandList.Get(), m_indexBuffer.Get(), m_indexBufferUpload.Get(), 0, 0, 1, &indexData);
        commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_indexBuffer.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_INDEX_BUFFER));

        PIXEndEvent(commandList.Get());
    }

    // 初始化索引缓冲区视图。
    m_indexBufferView.BufferLocation = m_indexBuffer->GetGPUVirtualAddress();
    m_indexBufferView.SizeInBytes = SampleAssets::IndexDataSize;
    m_indexBufferView.Format = SampleAssets::StandardIndexFormat;
}
```

4. 创建纹理和着色器资源视图。纹理从公共状态更改为目标，然后从目标更改为像素着色器资源。

```C++
// Create each texture and SRV descriptor.
    const UINT srvCount = _countof(SampleAssets::Textures);
    PIXBeginEvent(commandList.Get(), 0, L"Copy diffuse and normal texture data to default resources...");
    for (int i = 0; i < srvCount; i++)
    {
        // Describe and create a Texture2D.
        const SampleAssets::TextureResource &tex = SampleAssets::Textures[i];
        CD3DX12_RESOURCE_DESC texDesc(
            D3D12_RESOURCE_DIMENSION_TEXTURE2D,
            0,
            tex.Width, 
            tex.Height, 
            1,
            static_cast<UINT16>(tex.MipLevels),
            tex.Format,
            1, 
            0,
            D3D12_TEXTURE_LAYOUT_UNKNOWN,
            D3D12_RESOURCE_FLAG_NONE);

        ThrowIfFailed(m_device->CreateCommittedResource(
            &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
            D3D12_HEAP_FLAG_NONE,
            &texDesc,
            D3D12_RESOURCE_STATE_COPY_DEST,
            nullptr,
            IID_PPV_ARGS(&m_textures[i])));

        {
            const UINT subresourceCount = texDesc.DepthOrArraySize * texDesc.MipLevels;
            UINT64 uploadBufferSize = GetRequiredIntermediateSize(m_textures[i].Get(), 0, subresourceCount);
            ThrowIfFailed(m_device->CreateCommittedResource(
                &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
                D3D12_HEAP_FLAG_NONE,
                &CD3DX12_RESOURCE_DESC::Buffer(uploadBufferSize),
                D3D12_RESOURCE_STATE_GENERIC_READ,
                nullptr,
                IID_PPV_ARGS(&m_textureUploads[i])));

            // Copy data to the intermediate upload heap and then schedule a copy 
            // from the upload heap to the Texture2D.
            D3D12_SUBRESOURCE_DATA textureData = {};
            textureData.pData = pAssetData + tex.Data->Offset;
            textureData.RowPitch = tex.Data->Pitch;
            textureData.SlicePitch = tex.Data->Size;

            UpdateSubresources(commandList.Get(), m_textures[i].Get(), m_textureUploads[i].Get(), 0, 0, subresourceCount, &textureData);
            commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_textures[i].Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));
        }

        // Describe and create an SRV.
        D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
        srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
        srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
        srvDesc.Format = tex.Format;
        srvDesc.Texture2D.MipLevels = tex.MipLevels;
        srvDesc.Texture2D.MostDetailedMip = 0;
        srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;
        m_device->CreateShaderResourceView(m_textures[i].Get(), &srvDesc, cbvSrvHandle);

        // Move to the next descriptor slot.
        cbvSrvHandle.Offset(cbvSrvDescriptorSize);
    }
```

5. 开始一帧；这不仅使用 ResourceBarrier 来指示后备缓冲区将用作渲染目标，而且还初始化帧资源（在深度模板缓冲区上调用 ResourceBarrier）。

```c++
// Assemble the CommandListPre command list.
void D3D12Multithreading::BeginFrame()
{
    m_pCurrentFrameResource->Init();

    // Indicate that the back buffer will be used as a render target.
    m_pCurrentFrameResource->m_commandLists[CommandListPre]->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    // Clear the render target and depth stencil.
    const float clearColor[] = { 0.0f, 0.0f, 0.0f, 1.0f };
    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap->GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_pCurrentFrameResource->m_commandLists[CommandListPre]->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_pCurrentFrameResource->m_commandLists[CommandListPre]->ClearDepthStencilView(m_dsvHeap->GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    ThrowIfFailed(m_pCurrentFrameResource->m_commandLists[CommandListPre]->Close());
}

// Assemble the CommandListMid command list.
void D3D12Multithreading::MidFrame()
{
    // Transition our shadow map from the shadow pass to readable in the scene pass.
    m_pCurrentFrameResource->SwapBarriers();

    ThrowIfFailed(m_pCurrentFrameResource->m_commandLists[CommandListMid]->Close());
}
```

6. 结束一帧，表明后台缓冲区现在用于呈现。

```C++
// Assemble the CommandListPost command list.
void D3D12Multithreading::EndFrame()
{
    m_pCurrentFrameResource->Finish();

    // Indicate that the back buffer will now be used to present.
    m_pCurrentFrameResource->m_commandLists[CommandListPost]->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_pCurrentFrameResource->m_commandLists[CommandListPost]->Close());
}
```

7. 初始化帧资源（在开始帧时调用）将深度模板缓冲区转换为可写。

```c++
void FrameResource::Init()
{
    // Reset the command allocators and lists for the main thread.
    for (int i = 0; i < CommandListCount; i++)
    {
        ThrowIfFailed(m_commandAllocators[i]->Reset());
        ThrowIfFailed(m_commandLists[i]->Reset(m_commandAllocators[i].Get(), m_pipelineState.Get()));
    }

    // Clear the depth stencil buffer in preparation for rendering the shadow map.
    m_commandLists[CommandListPre]->ClearDepthStencilView(m_shadowDepthView, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    // Reset the worker command allocators and lists.
    for (int i = 0; i < NumContexts; i++)
    {
        ThrowIfFailed(m_shadowCommandAllocators[i]->Reset());
        ThrowIfFailed(m_shadowCommandLists[i]->Reset(m_shadowCommandAllocators[i].Get(), m_pipelineStateShadowMap.Get()));

        ThrowIfFailed(m_sceneCommandAllocators[i]->Reset());
        ThrowIfFailed(m_sceneCommandLists[i]->Reset(m_sceneCommandAllocators[i].Get(), m_pipelineState.Get()));
    }
}
```

8. 障碍物在帧中交换，将阴影贴图从可写转换为可读。

```C++
void FrameResource::SwapBarriers()
{
    // Transition the shadow map from writeable to readable.
    m_commandLists[CommandListMid]->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_shadowTexture.Get(), D3D12_RESOURCE_STATE_DEPTH_WRITE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));
}
```

9. 当一帧结束时调用 Finish，将阴影贴图转换为常见状态。

```C++
void FrameResource::Finish()
{
    m_commandLists[CommandListPost]->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(m_shadowTexture.Get(), D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_DEPTH_WRITE));
}
```

### Spilt barriers 的例子

下面的代码不使用分隔屏障

```C++
D3D12_RESOURCE_BARRIER BarrierDesc = {};
    BarrierDesc.Type = D3D12_RESOURCE_BARRIER_TRANSITION;
    BarrierDesc.Flags = D3D12_RESOURCE_BARRIER_NONE;
    BarrierDesc.Transition.pResource = pResource;
    BarrierDesc.Transition.Subresource = 0;
    BarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_COMMON;
    BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;

    pCommandList->ResourceBarrier( 1, &BarrierDesc );

    Write(pResource); // ... render to pResource
    OtherStuff(); // .. other gpu work

    // Transition pResource to PIXEL_SHADER_RESOURCE
    BarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
    BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;

    pCommandList->ResourceBarrier( 1, &BarrierDesc );

    Read(pResource); // ... read from pResource
```

下面的代码使用Spilt Barriers

```C++
D3D12_RESOURCE_BARRIER BarrierDesc = {};
    BarrierDesc.Type = D3D12_RESOURCE_BARRIER_TRANSITION;
    BarrierDesc.Flags = D3D12_RESOURCE_BARRIER_NONE;
    BarrierDesc.Transition.pResource = pResource;
    BarrierDesc.Transition.Subresource = 0;
    BarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_COMMON;
    BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;

    pCommandList->ResourceBarrier( 1, &BarrierDesc );

    Write(pResource); // ... render to pResource

    // Done writing to pResource. Start barrier to PIXEL_SHADER_RESOURCE and
    // then do other work
    BarrierDesc.Flags = D3D12_RESOURCE_BARRIER_BEGIN_ONLY;
    BarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
    BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
    pCommandList->ResourceBarrier( 1, &BarrierDesc );

    OtherStuff(); // .. other gpu work

    // Need to read from pResource so end barrier
    BarrierDesc.Flags = D3D12_RESOURCE_BARRIER_END_ONLY;

    pCommandList->ResourceBarrier( 1, &BarrierDesc );
    Read(pResource); // ... read from pResource
```

### DX12 图形渲染管道全局一览

![img](https://learn.microsoft.com/en-us/windows/win32/direct3d12/images/pipeline.png)

# DX12 的资源绑定

DX12 资源绑定的目的：

* 低开销
* 硬件可扩展性

## 描述符

描述符是一个相对较小的数据块，以 GPU 特定的不透明格式向 GPU 完整描述对象。注意同一个资源可以有不同的视图。

learnopengl 语言中使用了bind操作将我们要使用的数据绑定流水线中 。

```c++
glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```

### 描述符句柄

描述符句柄是描述符的唯一地址。它类似于指针，但不透明，因为它的实现是特定于硬件的。该句柄在描述符堆中是唯一的，因此，例如，句柄数组可以引用多个堆中的描述符。

### 顶点索引描述符

创建描述符视图经常需要填写对应的结构体：

要创建索引缓冲区视图，请填写[**D3D12_INDEX_BUFFER_VIEW**](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_index_buffer_view)结构

```C++
typedef struct D3D12_INDEX_BUFFER_VIEW
{
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
    UINT SizeInBytes;
    DXGI_FORMAT Format;
}D3D12_INDEX_BUFFER_VIEW;
```

以`D3D12_INDEX_BUFFER_VIEW` 为例描述符通常需要提供`D3D12_GPU_VIRTUAL_ADDRESS`GPU虚拟地址与缓冲区大小。

### 着色器资源视图

```C++
typedef struct D3D12_SHADER_RESOURCE_VIEW_DESC  
    {  
    DXGI_FORMAT Format;  
    D3D12_SRV_DIMENSION ViewDimension;  
    UINT Shader4ComponentMapping;  
    union   
        {  
        D3D12_BUFFER_SRV Buffer;  
        D3D12_TEX1D_SRV Texture1D;  
        D3D12_TEX1D_ARRAY_SRV Texture1DArray;  
        D3D12_TEX2D_SRV Texture2D;  
        D3D12_TEX2D_ARRAY_SRV Texture2DArray;  
        D3D12_TEX2DMS_SRV Texture2DMS;  
        D3D12_TEX2DMS_ARRAY_SRV Texture2DMSArray;  
        D3D12_TEX3D_SRV Texture3D;  
        D3D12_TEXCUBE_SRV TextureCube;  
        D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray;  
        }   ;  
    }   D3D12_SHADER_RESOURCE_VIEW_DESC;
```

下面是一个SRV的创建示例

```C++
// Describe and create an SRV.
D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
srvDesc.Format = tex.Format;
srvDesc.Texture2D.MipLevels = tex.MipLevels;
srvDesc.Texture2D.MostDetailedMip = 0;
srvDesc.Texture2D.ResourceMinLODClamp = 0.0f;
m_device->CreateShaderResourceView(m_textures[i].Get(), &srvDesc, cbvSrvHandle);
```

### 恒定缓冲区视图

```C++
typedef struct D3D12_CONSTANT_BUFFER_VIEW_DESC {
  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
  UINT   SizeInBytes;
} D3D12_CONSTANT_BUFFER_VIEW_DESC;
```

size 大小这摸奇怪的原因是因为常量缓冲区需要遵循硬件的内存对齐规则

```C++
D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc = {};
cbvDesc.BufferLocation = m_constantBuffer->GetGPUVirtualAddress();
cbvDesc.SizeInBytes = (sizeof(ConstantBuffer) + 255) & ~255;    // CB size is required to be 256-byte aligned.
m_device->CreateConstantBufferView(&cbvDesc, m_cbvHeap->GetCPUDescriptorHandleForHeapStart());
```

调用[`ID3D12Device::CreateConstantBufferView`](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createconstantbufferview) 来创建视图。

### Sampler

```C++
typedef struct D3D12_SAMPLER_DESC
{
    D3D12_FILTER Filter;
    D3D12_TEXTURE_ADDRESS_MODE AddressU;
    D3D12_TEXTURE_ADDRESS_MODE AddressV;
    D3D12_TEXTURE_ADDRESS_MODE AddressW;
    FLOAT MipLODBias;
    UINT MaxAnisotropy;
    D3D12_COMPARISON_FUNC ComparisonFunc;
    FLOAT BorderColor[4]; // RGBA
    FLOAT MinLOD;
    FLOAT MaxLOD;
} D3D12_SAMPLER_DESC;
```

调用[`ID3D12Device::CreateSampler`](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsampler) 创建

### 无序访问视图

要创建无序访问视图，需要填写[**D3D12_UNORDERED_ACCESS_VIEW_DESC**](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_unordered_access_view_desc)结构：

```C++
typedef struct D3D12_UNORDERED_ACCESS_VIEW_DESC
{
    DXGI_FORMAT Format;
    D3D12_UAV_DIMENSION ViewDimension;
    union
    {
        D3D12_BUFFER_UAV Buffer;
        D3D12_TEX1D_UAV Texture1D;
        D3D12_TEX1D_ARRAY_UAV Texture1DArray;
        D3D12_TEX2D_UAV Texture2D;
        D3D12_TEX2D_ARRAY_UAV Texture2DArray;
        D3D12_TEX3D_UAV Texture3D;
    };
} D3D12_UNORDERED_ACCESS_VIEW_DESC;
```

最后调用[`ID3D12Device::CreateUnorderedAccessView`](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createunorderedaccessview) 创建

### 流输出视图

没咋用过，等用过了再看看

### 渲染目标视图

要创建渲染目标视图，请填写[**D3D12_RENDER_TARGET_VIEW_DESC**](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_render_target_view_desc)结构

```C++
typedef struct D3D12_RENDER_TARGET_VIEW_DESC
{
    DXGI_FORMAT Format;
    D3D12_RTV_DIMENSION ViewDimension;

    union
    {
        D3D12_BUFFER_RTV Buffer;
        D3D12_TEX1D_RTV Texture1D;
        D3D12_TEX1D_ARRAY_RTV Texture1DArray;
        D3D12_TEX2D_RTV Texture2D;
        D3D12_TEX2D_ARRAY_RTV Texture2DArray;
        D3D12_TEX2DMS_RTV Texture2DMS;
        D3D12_TEX2DMS_ARRAY_RTV Texture2DMSArray;
        D3D12_TEX3D_RTV Texture3D;
    };
} D3D12_RENDER_TARGET_VIEW_DESC;
```

最后，调用[**ID3D12Device::CreateRenderTargetView**](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview)。

### 深度模板视图

要创建深度模板视图，请填写[**D3D12_DEPTH_STENCIL_VIEW_DESC**](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/ns-d3d12-d3d12_depth_stencil_view_desc)结构：

```c++
typedef struct D3D12_DEPTH_STENCIL_VIEW_DESC  
    {  
    DXGI_FORMAT Format;  
    D3D12_DSV_DIMENSION ViewDimension;  
    D3D12_DSV_FLAGS Flags;  
    union   
        {  
        D3D12_TEX1D_DSV Texture1D;  
        D3D12_TEX1D_ARRAY_DSV Texture1DArray;  
        D3D12_TEX2D_DSV Texture2D;  
        D3D12_TEX2D_ARRAY_DSV Texture2DArray;  
        D3D12_TEX2DMS_DSV Texture2DMS;  
        D3D12_TEX2DMS_ARRAY_DSV Texture2DMSArray;  
        }   ;  
    }   D3D12_DEPTH_STENCIL_VIEW_DESC;
```

## 资源描述堆

### 资源描述符堆概述

**为啥要使用描述符堆**

Direct3D 12 对描述符堆的使用反映了大多数 GPU 硬件的做法，即要求描述符仅存在于描述符堆中，或者如果使用这些堆，则需要更少的寻址位。如果存在堆中

描述符堆包含许多不属于管道状态对象 (PSO) 的对象类型，例如着色器资源视图 (SRV)、无序访问视图 (UAV)、常量缓冲区视图 (CBV) 和采样器。

描述符堆的主要目的是包含存储着色器在尽可能大的渲染窗口（理想情况下是整个渲染帧或更多）引用的对象类型的描述符规范所需的大量内存分配。如果应用程序正在切换管道从 API 快速看到的纹理，则描述符堆中必须有空间来为所需的每组状态动态定义描述符表。例如，如果资源在另一个对象中再次使用，应用程序可以选择重用定义，或者在切换各种对象类型时仅按顺序分配堆空间。

描述符堆还允许各个软件组件彼此分开管理描述符存储。

### 着色器可见描述符堆

Desc.Flags = (bShaderVisible ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE);

着色器可见描述堆事可以通过描述符表引用的描述符堆。

### 着色器不可见描述符堆

|               | Shader visible, CPU write only | Non-shader visible, CPU read/write |
|:------------- |:------------------------------ | ---------------------------------- |
| CBV, SRV, UAV | yes                            | yes                                |
| SAMPLER       | yes                            | yes                                |
| RTV           | no                             | yes                                |
| DSV           | no                             | yes                                |

区分**着色器可见描述符堆**和**着色器不可见描述符堆**主要是出于性能优化和资源管理的考虑。这两种类型的描述符堆在DirectX 12等现代图形API中发挥着不同的角色，它们共同支持了更高效、更灵活的渲染流程。下面，我会详细解释这种区分的原因：

性能优化

1. **减少状态切换**: 着色器可见描述符堆允许GPU直接访问那些频繁被使用或在渲染过程中需要快速切换的资源，这样可以减少CPU到GPU的命令提交，降低状态切换的开销。在GPU执行渲染任务时，减少这种开销对于提升性能至关重要。
2. **提高访问速度**: 由于着色器可见描述符堆中的资源可以被GPU直接访问，这意味着着色器在运行时可以更快地获取到所需的资源信息，进一步提高渲染效率。

资源管理

1. **组织和管理资源**: 通过区分着色器可见和不可见的描述符堆，开发者可以更好地组织和管理资源。例如，一些不经常访问的资源或只在特定情况下需要的资源可以放在着色器不可见描述符堆中，而那些需要频繁访问的热点资源则放在着色器可见描述符堆中。
2. **灵活的资源更新**: 对于着色器不可见描述符堆中的资源，开发者可以在CPU端进行更新或更换，而不直接影响GPU的执行。这为资源的动态更新提供了一定的灵活性。当更新完毕后，相关的描述符可以被复制到着色器可见描述符堆中，供GPU使用。

### 描述符堆类型

堆的类型由[**D3D12_DESCRIPTOR_HEAP_TYPE**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_heap_type)枚举的一个成员确定：

```C++
typedef enum D3D12_DESCRIPTOR_HEAP_TYPE
{
    D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,    // Constant buffer/Shader resource/Unordered access views
    D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER,        // Samplers
    D3D12_DESCRIPTOR_HEAP_TYPE_RTV,            // Render target view
    D3D12_DESCRIPTOR_HEAP_TYPE_DSV,            // Depth stencil view
    D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES       // Simply the number of descriptor heap types
} D3D12_DESCRIPTOR_HEAP_TYPE;
```

例如，描述并创建采样器描述符堆。

```C++
// Describe and create a sampler descriptor heap.
D3D12_DESCRIPTOR_HEAP_DESC samplerHeapDesc = {};
samplerHeapDesc.NumDescriptors = 1;
samplerHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;
samplerHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
ThrowIfFailed(m_device->CreateDescriptorHeap(&samplerHeapDesc, IID_PPV_ARGS(&m_samplerHeap)));
```

描述并创建常量缓冲区视图 (CBV)、着色器资源视图 (SRV) 和无序访问视图 (UAV) 描述符堆。

```C++
// Describe and create a shader resource view (SRV) and unordered
// access view (UAV) descriptor heap.
D3D12_DESCRIPTOR_HEAP_DESC srvUavHeapDesc = {};
srvUavHeapDesc.NumDescriptors = DescriptorCount;
srvUavHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
srvUavHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
ThrowIfFailed(m_device->CreateDescriptorHeap(&srvUavHeapDesc, IID_PPV_ARGS(&m_srvUavHeap)));

m_rtvDescriptorSize = m_device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
m_srvUavDescriptorSize = m_device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
```

描述符堆 ( [**ID3D12DescriptorHeap**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/nn-d3d12-id3d12descriptorheap) ) 继承自[**ID3D12Pageable**](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nn-d3d12-id3d12pageable)。这将描述符堆的驻留管理责任强加给应用程序，就像资源堆一样。驻留管理方法仅适用于着色器可见堆，因为非着色器可见堆对 GPU 不直接可见。

描述符堆 ( [**ID3D12DescriptorHeap**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/nn-d3d12-id3d12descriptorheap) ) 继承自[**ID3D12Pageable**](https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nn-d3d12-id3d12pageable)。这将描述符堆的驻留管理责任强加给应用程序，就像资源堆一样。驻留管理方法仅适用于着色器可见堆，因为非着色器可见堆对 GPU 不直接可见。

ID3D12Device [**::GetDescriptorHandleIncrementSize**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/nf-d3d12-id3d12device-getdescriptorhandleincrementsize)方法允许应用程序手动将句柄偏移到堆中（将句柄生成到描述符堆中的任何位置）。堆起始位置的句柄来自[**ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/nf-d3d12-id3d12descriptorheap-getcpudescriptorhandleforheapstart) / [**ID3D12DescriptorHeap::GetGPUDescriptorHandleForHeapStart**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/nf-d3d12-id3d12descriptorheap-getgpudescriptorhandleforheapstart)。偏移是通过将增量大小 * 要偏移的描述符数量添加到描述符堆起始位置来完成的。请注意，增量大小不能被视为字节大小，因为应用程序不得像内存一样取消引用句柄 - 指向的内存具有非标准化布局，甚至对于给定设备也可能有所不同。

[**GetCPUDescriptorHandleForHeapStart**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/nf-d3d12-id3d12descriptorheap-getcpudescriptorhandleforheapstart)返回 CPU 可见描述符堆的 CPU 句柄。如果描述符堆对 CPU 不可见，它会返回 NULL 句柄（并且调试层将报告错误）。

[**GetGPUDescriptorHandleForHeapStart**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/nf-d3d12-id3d12descriptorheap-getgpudescriptorhandleforheapstart)返回着色器可见描述符堆的 GPU 句柄。如果描述符堆对着色器不可见，它将返回 NULL 句柄（并且调试层将报告错误）。

### 两种对比

|              | 着色器可见描述符堆                            | 非着色器可见描述符堆                                                                                                          |
|:------------ |:------------------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| 支持的堆类型       | CBV_SRV_UAV，采样器                      | 全部                                                                                                                  |
| 支持的 CPU 页面属性 | NOT_AVAILABLE，WRITE_COMBINE          | 写回                                                                                                                  |
| 通过应用程序进行居住管理 | 是的，应用程序负责                            | 不适用（GPU 不可见）。                                                                                                       |
| 描述符编辑支持      | 仅复制目标，通过命令列表更新和/或 CPU 复制（如果 CPU 可见）。 | CPU 只能读取和写入。无法直接访问 GPU。可用于立即 CPU 复制（作为源和目标）。可用作命令列表上的更新源 - 这将在命令列表记录期间将描述符复制到命令列表存储中。执行时，存储的副本将被复制到目标，该目标必须是着色器可见堆。 |

## 描述符表

### 描述符概述

图形管道通过根签名，参考描述符表中的索引来获得对资源的访问。

描述符表实际上只是描述符堆的一个子范围。描述符堆表示描述符集合的底层内存分配。由于内存分配是创建描述符堆的一个属性，因此从一个描述符表中定义一个描述符表可以保证与硬件识别堆中的区域一样便宜。描述符表不需要在 API 级别创建或销毁 - 它们只是在引用时被驱动程序识别为堆外的偏移量和大小。

当应用程序的着色器希望能够自由地从大量可用描述符（通常引用纹理）中动态（可能由材质数据驱动）进行选择时，应用程序当然可以定义非常大的描述符表。

根签名通过对堆的引用、表的起始位置（距堆起始的偏移量）和表的长度（以条目为单位）来引用描述符表条目。下图显示了这些概念：来自根签名的描述符表指针以及引用堆中完整纹理或缓冲区数据的描述符堆中的描述符（对于纹理，为默认堆）。

![描述符表](https://learn.microsoft.com/en-us/windows/win32/direct3d12/images/descriptor-table.png)

描述符表（每个描述符表标识描述符堆中的范围）绑定在命令列表上当前根签名定义的槽处。

## 根签名

**根签名**类似于API 函数签名，它确定着色器应该期望的数据类型，但不定义实际的内存或数据。根**参数**是根签名中的一项。在运行时设置和更改的根参数的实际值称为**根参数**。更改根参数会更改着色器读取的数据。

根签名可以包含三种类型的参数；根常量（内联在根参数中的常量）、根描述符（内联在根参数中的描述符）和描述符表（指向描述符堆中一系列描述符的指针）。

根常量是内联 32 位值，在着色器中显示为常量缓冲区。

内联根描述符应包含最常访问的描述符，但仅限于 CBV、原始或结构化 UAV 或 SRV 缓冲区。更复杂的类型（例如 2D 纹理 SRV）不能用作根描述符。根描述符不包含大小限制，因此不能进行越界检查，这与描述符堆中的描述符不同，描述符堆中的描述符确实包含大小。

根签名中的描述符表条目包含描述符、HLSL 着色器绑定名称和可见性标志。有关着色器名称的详细信息，请参阅[着色器模型 5.1](https://learn.microsoft.com/en-us/windows/desktop/direct3dhlsl/shader-model-5-1)。在某些硬件上，仅使描述符对需要它们的着色器阶段可见可以提高性能（请参阅[**D3D12_SHADER_VISIBILITY**](https://learn.microsoft.com/en-us/windows/desktop/api/d3d12/ne-d3d12-d3d12_shader_visibility)）。

### 根签名（Root Signature）

根签名定义了着色器程序所需的资源（如常量缓冲区、纹理、采样器等）的访问方式和组织结构。它是DirectX 12渲染管线状态的一部分，用于确定着色器可访问哪些资源以及如何访问。

根签名定义了一系列根参数，这些参数可以是描述符表、根描述符或根常量。根参数可以直接绑定到管线上，或者指向描述符堆中的资源。根签名使得你可以将资源绑定到管线而不需要绑定整个资源表，这样可以大幅提高绑定资源的灵活性和性能。

### 总结：

图形和计算管道通过索引引用描述符表来访问资源。

描述符表存储在*描述符堆中*。理想情况下，描述符堆将包含要渲染的一帧或多帧的所有描述符（在描述符表中）。所有资源都将存储在用户模式堆中。

另一个概念是*根签名*。根签名是由应用程序定义的绑定约定，着色器使用它来定位它们需要访问的资源。根签名可以存储：

- 描述符堆中描述符表的索引，其中描述符表的布局已预先定义。
- 常量，因此应用程序可以将用户定义的常量（称为*根常量*）直接绑定到着色器，而无需通过描述符和描述符表。
- 直接位于根签名内部的极少数描述符，例如每次绘制都会更改的常量缓冲区视图 (CBV)，从而使应用程序无需将这些描述符放入描述符堆中。

换句话说，根签名提供了适合每次绘制更改的少量数据的性能优化。

Direct3D 12 的绑定设计将其与其他任务分开，例如内存管理、对象生存期管理、状态跟踪和内存同步（请参阅[绑定模型与 Direct3D 11 的差异](https://learn.microsoft.com/en-us/windows/win32/direct3d12/binding-model)）。Direct3D 12 绑定旨在降低开销，并针对最频繁进行的 API 调用进行了优化。它还可以跨低端硬件扩展到高端硬件，并且可以从旧的（更线性的 Direct3D 11 管道）扩展到更新的（更并行的）图形引擎编程方法。

### 区别

- **用途不同**：
  - 顶点输入布局专注于如何读取和解释顶点数据。
  - 根签名则定义了着色器与其所需资源之间的接口。
- **作用阶段不同**：
  - 顶点输入布局工作在输入装配阶段，确定如何从顶点缓冲区取得顶点数据。
  - 根签名贯穿整个渲染管线，决定着色器如何访问缓冲区、纹理等资源。
- **配置层级不同**：
  - 顶点输入布局是管线状态对象（PSO）的一部分，它与特定的顶点缓冲区和顶点着色器紧密相关。
  - 根签名是更高层次的概念，可以被多个管线状态对象共享，它描述了构成渲染任务的资源布局。
- **灵活性和性能影响**：
  - 顶点输入布局的改变通常意味着对顶点缓冲区结构的改变，这在运行时较少发生。
  - 根签名的设计对于性能有很大影响，因为它决定了着色器如何高效地访问它们所需的资源。

理解这两个概念是如何分别影响DirectX 12渲染管线的不同部分的，对于编写高效的图形程序至关重要。

### 使用根签名

那么为什么需要根签名这么一个结构化的描述呢？这是因为无论什么数据，在存储中都是线性化的按字节依次排列在存储（内存及显存）中的，如果不加额外的描述信息来说明，GPU甚至CPU本身根本无法分辨那块存储器中存储的是什么数据，即没有类型说明的数据，这类似C语言中的VOID*指针指向的一块数据，如果不额外说明，根本不知道里面到底存了些什么。所以根签名从根本上为这些存储的数据描述清楚了基本类型信息和位置信息。当数据按照指定的方式传递到指定的位置后，GPU就可以按照根签名中的约定访问这些数据了。而进一步的详细的类型信息则是由各种描述符来详细描述了。

根签名描述清楚了渲染管线或者说Shader编译后的执行代码需要的各种资源以什么样的方式传入以及如何在内存、显存中布局，当然主要指定的是GPU上对应的寄存器。另一种等价的说法是说如何将这些数据绑定到渲染管线上，实质是说的一回事情，只是角度不同。

### 根参数

```C++
 rootParameters[RootParameters::MatricesCB].InitAsConstantBufferView( 0, 0, D3D12_ROOT_DESCRIPTOR_FLAG_NONE, D3D12_SHADER_VISIBILITY_VERTEX );
    rootParameters[RootParameters::MaterialCB].InitAsConstantBufferView( 0, 1, D3D12_ROOT_DESCRIPTOR_FLAG_NONE, D3D12_SHADER_VISIBILITY_PIXEL );
    rootParameters[RootParameters::LightPropertiesCB].InitAsConstants( sizeof( LightProperties ) / 4, 1, 0, D3D12_SHADER_VISIBILITY_PIXEL );
    rootParameters[RootParameters::PointLights].InitAsShaderResourceView( 0, 0, D3D12_ROOT_DESCRIPTOR_FLAG_NONE, D3D12_SHADER_VISIBILITY_PIXEL );
    rootParameters[RootParameters::SpotLights].InitAsShaderResourceView( 1, 0, D3D12_ROOT_DESCRIPTOR_FLAG_NONE, D3D12_SHADER_VISIBILITY_PIXEL );
    rootParameters[RootParameters::Textures].InitAsDescriptorTable( 1, &descriptorRage, D3D12_SHADER_VISIBILITY_PIXEL );
```

上述代码的说明：

`RootParameters::MatricesCB` 是枚举类型

根参数是根签名的核心组成部分，它定义了着色器可以访问的各种资源。根参数可以是常量缓冲区视图（CBV）、着色器资源视图（SRV）、无序访问视图（UAV）、采样器等。

chus

```C++
void InitAsConstantBufferView(
  UINT shaderRegister,
  UINT registerSpace = 0,
  D3D12_ROOT_DESCRIPTOR_FLAGS flags = D3D12_ROOT_DESCRIPTOR_FLAG_NONE,
  D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL
);
```

- `shaderRegister` 指定了常量缓冲区绑定到的寄存器编号。
- `registerSpace` 用于指定寄存器空间，可以用来区分不同类型的资源。
- `visibility` 指定了哪些着色器阶段可以看到这个常量缓冲区。

```C++
void InitAsShaderResourceView(
  UINT shaderRegister,
  UINT registerSpace = 0,
  D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL
);
```

- `shaderRegister`、`registerSpace` 和 `visibility` 的含义同上。

```C++
void InitAsDescriptorTable(
  UINT numDescriptorRanges,
  const D3D12_DESCRIPTOR_RANGE* pDescriptorRanges,
  D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL
);
```

- `numDescriptorRanges` 指定了描述符范围的数量。
- `pDescriptorRanges` 是指向描述符范围数组的指针，每个范围定义了一组资源的类型、数量和绑定方式。
- `visibility` 指定了哪些着色器阶段可以看到这个描述符表。

# Computer Shader

`SV_GroupIndex`使用以下公式计算：
$$
\begin{array}{rcl} 
GroupIndex & = & GroupThreadID.z \cdot numthreads.x \cdot numthreads.y \\ 
& + & GroupThreadID.y \cdot numthreads.x \\ 
& + & GroupThreadID.x 
\end{array}
$$
