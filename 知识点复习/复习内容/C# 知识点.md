# C# 知识点

## 关键字

### sealed

只能用于修饰类和虚函数，被修饰的类不允许派生子类，被修饰到的虚函数不允许被重写

[C#中sealed的用法_c# sealed-CSDN博客](https://blog.csdn.net/qq_40323256/article/details/86771078?ops_request_misc=&request_id=&biz_id=102&utm_term=sealed%E7%9A%84%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86771078.142%5Ev42%5Enew_blog_pos_by_title,185%5Ev2%5Econtrol&spm=1018.2226.3001.4187)

### ref 与 out

解决值类型和引用类型在函数内部改值或者重新申明能够影响外部传入的变量让其也被修改。

**使用**: 就是在申明参数的时候前面加上ref和out的关键字即可，传入参数时同上。

* ref传入的变量必须初始化但 [设计模式.md](设计模式.md) 是在内部可改可不改。

* out传入的变量不用初始化但是在内部必须修改该值(必须赋值）。

### unsafe

被该关键字修饰的代码块，可以允许我们使用指针，使用的方法跟C++ 里的基本一致：[C#【必备技能篇】不安全代码（unsafe）的使用_什么场景会用到c#unsafe模式-CSDN博客](https://blog.csdn.net/sinat_40003796/article/details/118358868)

```C#
static unsafe void Main()
{
    int num = 5;
    int* p = &num;
    unsafe
    {
        int num1 = 5;
        int* p1 = &num1;
    }
}
```

## 值类型引用类型相关问题

### 引用类型 继承System.Object：

引用类型当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。

* 内存必须从托管堆分配

* 堆上分配的每一个对象都有一些额外的成员对象，这些成员对象必须初始化

* 对象中的其他字节总是设为零

* 从托管堆中分配对象时可能触发GC

### 值类型 继承System.ValueType：

值类型变量声明后，不管是否已经赋值，编译器为其分配内存。

* 内存不一定全会分配在栈区，也有可能分配在堆区

* 不管是否已经赋值，编译器均为其分配内存

注：各种类型的数据的内存分配

数组的元素不管是引用类型还是值类型，都存储在托管堆上。

引用类型在栈中存储一个引用，其实际的存储位置位于托管堆。简称引用类型部署在托管推上。而值类型总是分配在它声明的地方：作为字段时，跟随其所属的变量（实 例）存储；作为局部变量时，存储在栈上。（栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放）

### 拆箱与装箱

装箱发生：

* 首先在托管堆中分配好内存，分配的内存量是值类型字段需要的内存量加上托管堆上需要的对象的两个额外成员（对象指针，同步块索引）需要的内存。

* 值类型的字段复制到新分配的内存中。

* 返回对象的地址，也就是对象的引用。

拆箱发生:

* 获取已装箱的值类型实例的指针。

* 把获取到的值复制到栈。

拆箱过程

比如在下面代码中会出现错误

```C#
int value = 42;
object obj = value;
long test = (long)value;
```

 使用泛型来避免频繁的拆箱装箱

### 类和结构有以下几个基本的不同点：

* 类是引用类型，结构是值类型。

* 结构不支持继承。

* 结构不能声明默认的构造函数。

## 字符串

### 字符串常量池

字符串常量池可以减少相同字符串在堆中被重复创建的情况，结论是尽量不要使用 new 来创建字符串，因为这种情况是直接在堆中创建对象，而不是先在字符串常量池中寻找是否有对应字符串。

[JAVA / C# 详解之：运行时常量池 (string/stringBuilder)_java运行时常量池-CSDN博客](https://blog.csdn.net/weixin_46484674/article/details/125001216)

### StringBuilder

当需要频繁拼接字符串时，会在字符串常量库中创建大量的字符串，产生大量内存垃圾，而针对这种情况推荐使用 StringBuilder 创建字符串，其内部采用类似于链表的结构可以有效减少缓解这种情况。而 string 的好处就是泛用性强。

[String/StringBuilder/ToString()底层代码解析（ JAVA / C# ）_c#stringbuilder底层实现-CSDN博客](https://blog.csdn.net/weixin_46484674/article/details/124951029)

## 抽象类

抽象类就是指设计为被继承的类，抽象类只能被用作其他类的基类。

- 抽象类不能被创建实例。

- 抽象类可以包含抽象成员或普通的非抽象成员。（抽象成员下面会进行说明）

- 抽象类可以继承另一个抽象类

方法，属性，事件，索引器都可以为抽象成员。

## 抽象类和接口的区别

[C#中抽象类和接口的区别 - JunBird - 博客园](https://www.cnblogs.com/junbird-nest/archive/2012/10/25/2738177.html)

相同点：

* 不能实例化；

* 包含未实现的方法声明； 

* 派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法包括其他成员）；

不同点：

* 一个类可以直接继承多个接口，但只能直接继承一个类（包括抽象类）

* 抽象类的实现的具体方法默认为虚，在实现接口类中的方法默认为非虚

* 飞机会飞，鸟会飞，他们都继承了同一个接口“飞”；但是F22属于飞机抽象类，鸽子属于鸟抽象类。类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫做抽象类.而接口只是一个行为的规范或规定。

## 委托与事件

委托是一个类，它继承自System.MulticastDelegate，而MulticastDelegate又继承自System.Delegate。内部通过重委托链实现了功能。

[从使用层面上了解委托和事件的区别 - 陈哈哈 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kissazi2/p/3189685.html)

| 序号  | 区别           | 委托  | 事件           |
| --- | ------------ | --- | ------------ |
| 1   | 是否可以使用=来赋值   | 是   | 否            |
| 2   | 是否可以在类外部进行调用 | 是   | 否            |
| 3   | 是否是一个类型      | 是   | 否，事件修饰的是一个对象 |

## GC

[GC 相关](https://www.baidu.com/link?url=hL3jrEW80-1142BTvp0QwTvb2a1TNSgHmIHBhu64W-Q1-8_TkOJ_LMxtdeCx1ewW4EsysNnd5bVtF2aRxCWhPq&wd=&eqid=da7e16390000d36d000000036576c6b5)

**如何减少 GC**

* 减少临时变量的使用，多使用公共对象，多利用缓存机制。（将容器定义到函数外，用到容器的时候进行修改即可）

* 减少new对象的次数。

* 使用扩容的容器时，例如：List，StringBuilder等，定义时尽量根据存储变量的内存大小定义储存空间，减少扩容的操作。（扩容后，旧的容器直接抛弃等待GC）

* 利用对象池：对象池是一种Unity经常用到的内存管理服务，针对经常消失生成的对象，例如子弹，怪物等，作用在于减少创建每个对象的系统开销。在我们想要对象消除时，不直接Destory，而是隐藏起来SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。

* 减少装箱拆箱( 装箱是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程)的操作

* 协程： yeild return 0 会产生装箱拆箱，可以替换为 yeild return null。

**垃圾回收的策略** ：标记压缩 + 分代

标记：一开始为堆中的全部对象标识为可回收，再在堆上所有的对象建立一个有向图，通过有向图将对象标识为活动对象。垃圾收集器可以检测到所有的孤岛，将他们标识为垃圾。

压缩：将非垃圾对象进行移动，使得堆中的空间尽量连续。

垃圾回收主要在回收短生存期对象时发生。 为优化垃圾回收器的性能，根据程序的局部性原则，将托管堆分为三代：第 0 代、第 1 代和第 2 代。

### IDisposable 接口

资源分为两部分：非托管资源和托管资源，由 CLR(GC) 管理的资源就叫托管资源,反之则不是

[C# 的托管资源和非托管资源都有哪些 - LXLR - 博客园 (cnblogs.com)](https://www.cnblogs.com/LXLR/p/17877582.html)

当类内有非托管资源时，需要我们手动释放，C# 为了们定制了该接口，该接口中声明了 `void Dispose();` 函数，可以允许我们释放非托管资源。

但是 GC 不会帮我们们自动调用该函数，但又怕会忘记，所以有了一种标准的写法：[C#中的IDisposable模式用法详解_C#教程_脚本之家 (jb51.net)](https://www.jb51.net/article/54899.htm)

## 反射

[c#之反射详解_c# 反射-CSDN博客](https://blog.csdn.net/qq_39847278/article/details/129816667)

在C#编译的时候，就会将C#源代码编译成程序集，而我们可以在加载程序运行时，动态获取和加载程序集。

程序集中包含有Microsoft 中间语言 (MSIL) 和必需的元数据，反射可以读取程序集中的元数据，利用元数据创建对象，从而实现各种功能。（反编译是读取的IL代码）并且可以获取到程序集的信息反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段。

主要使用的类库：System.Reflection

## 协程

* C# 迭代器与协程

[理解协程](https://www.baidu.com/link?url=xipUotv3p42yhdQYZUy_qVTUSwCokjVOW2f1KCUdy9Hl3slCux-tfU3XhKWGRbqjE3nJeentYRkvNZXck2Iz6K&wd=&eqid=c5e6cbf7000324a00000000265265daa)

一个进程可以有多个线程，一个线程可以有多个协程

**协程**

* 协程是**用户级**的，协程完全由用户控制，协程切换开销比较小。

* 协程是**串行**的，在任何一个时刻，同一线程中的协程，只有一个协程在跑。

**线程**

* 线程是**内核级**的，共享进程内资源。线程调度需要操作系统进行调度，调度开销大。
- 线程是**并行**的，多个线程可以同时运行。因为是多线程共享资源，所有访问全局变量的时候要加锁。

简单来说：主要是通过**IEnumerator**来实现一个**迭代器**，然后每帧帧执行 MoveNext()方法。

协程的实现：

* IEnumerator

迭代器模式是设计模式中行为模式(behavioral pattern)的一种。  迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

[实现协程](https://zhuanlan.zhihu.com/p/106741659)

[C# 基础小知识之yield 关键字 语法糖 - dapeng888 - 博客园](https://www.cnblogs.com/niaowo/p/4720880.html)

[C# yield](https://zhuanlan.zhihu.com/p/330673270?utm_id=0)

## 委托

C#中的委托是一个类型，它描述了一个方法的参数类型和返回类型。委托可以看作是一个指向方法的引用，使得我们可以像使用函数指针一样调用这些方法。

Action<T> 表示无返回值的泛型委托

* 表示传入参数为T，无返回值的委托

Func<T>  表示有返回值的泛型委托

* Fun<int> 表示返回值为 int 的无参委托

* Fun<object,string,int> 表示返回值为 int ，参数为object,string 的委托。

## 容器相关

[C#List(链表)Dictionary(字典)源码剖析[Unity内功修炼-C#进阶01] - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/634380627)

List：底层实现是泛型数组，特性，动态扩容，泛型安全

Dirctionary ：底层实现是两个数组，通过拉链法避免的哈希冲突

```C#
private struct Entry {
    public int hashCode;   
    public int next; 
    public TKey key; 
    public TValue value;
}

private int[] buckets;
private Entry[] entries;
```



C# 中的hastable 使用的开放寻址法中的双重探测方法，如果寻址
