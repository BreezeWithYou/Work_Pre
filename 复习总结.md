### 面试介绍

面试官您好，我叫李嘉勤，是河北工业大学计算机科学与技术专业的大三学生。

我熟悉C#,C++编程语言。对于Unity（大二开始学习了2年） 和 Ue（学习了3个月） 引擎都比较熟悉，对于游戏开发中的动画与渲染模块了解的比较多。

个人一共有两段实习经历一个是现在的腾讯的和平精英项目组，（由于组比较偏向客户端引擎方向）主要工作是前两个月学习 Ue 引擎，后面开始深入学习动画系统和做IK方面的研究。另一个实习经历是上海冰炎，个人主要在其中负责UI 和一些简单模块的开发。

个人在校期间使用Unity引擎制作了三个游戏Demo(其中两个在简历上)，并使用DX12 api 制作的3D渲染器。

个人喜欢玩游戏，热爱游戏开发，在平时的学习中积累并将其记录在博客中。

### 渲染器项目总述：

**总述：**

个人DX12 项目目前做到了实现了前向渲染，光照模型实现了`bilin - phong` 和 `PBR`部分，可以加载贴图用ComputerShader 去做了Minmap。

个人主要是对原书中的类进行补充和划分，比如`Resource`基类其派生类有`Buffer`和`Texture`，`Buffer` 的派生类有`VertexBuffer` ，`UploadBuffer`,`IndexBuffer` `ConstantBuffer`。这样做主要是逻辑连贯，并且在基类中对资源进行统一管理（将Resource 添加到状态跟踪器中），在子类中区定义其独有方法。

还有就是添加了一些资源管理模块（对描述符的管理和对上传缓冲区的管理）， 

**问题：**

根签名和传入`Shader` 的参数不匹配 - 描述符堆出异常

封装`Mesh`这个类的时候顶点读数据我没有转化到对应的资源状态

（调试的话还真没有啥好办法，我一般是用备份，如果实在改不了就回档重新写）

**课程时间情况：**

计算机四大件：我深入学习过操作系统相关的一些知识。

计算机图形学：主要是通过Games101,部分202课程学习与一些书籍。图形Api 的实践主要通过LearnOpengl 这个网站学习与通过    DX12 搭建的一条简单的渲染管线。对于商业引擎的图形实践主要是在Unity 中使用ShaderLab 写Shader 做一些视觉效果。然后偶尔追一追Youyuber 上的GDC 翻译。

编程语言：C++,C#。C++ STL，多线程，一些C++11,C++14 的新标准都学习过。

游戏开发方面：我自己做过3个游戏Demo（其中有一个是合作完成的），总体上对游戏开发中除网络之外的部分均有涉及，也对自己涉及到比较多的部分UI，与自己感兴趣的动画部分有一些探索。

 **图形学学习：**

看过的书：以看博客为主，RTR4看了2/5，Games101,Games202,Games104。个人实践主要是Unity ShaderLab，学习过LearnOpengl 与 DX12 这俩图形API。然后偶尔追一追Youyuber 上的GDC 翻译。

### 常问的问题

DX12 相对于传统的图形API增加了什么

- 在 Direct3D 12 中，CPU-GPU 同步现在是应用程序的显式责任，不再像 Direct3D 11 中那样由运行时隐式执行。这一事实也意味着 Direct3D 12 不会执行管道危险的自动检查，所以这又是应用程序的责任。

- 使用PSO(PipelineStateObject）快速切换渲染状态 -> 每个指令需要显式地绑定对应地PSO，可以减少上下文切换的消耗。

- 需要使用 ResourceBarrir 手动指定资源的同步，与资源的内存管理

- 提供可控的内存分配堆 ，更精细的内存控制，为（保留资源）虚拟内存提供可能。

### 实习相关内容：

Lyra 动画系统

* 将动画数据的获取迁移到动画线程 `BlueprintThreadSafeUpdateAnimation` 

* 对于动画技术与复杂的动画逻辑的比如 `Distance match` 距离匹配，`Turn in Place` 原地转身。

* 整体动画框架，换成Unity来说就是 playable 去定义的各种的 PlayablebehiourNode 的组织与安排。（我从PlayableBehourNode 的根节点往叶子节点说起）：IK -> Aimoffset -> layered blend(分成 upper lower) -> apply active -> locamation

* 使用Animation layer interface，和子动画蓝图。去分离逻辑，可以做动画的数据驱动。动画的实现逻辑被切分在一个一个小的 Layer 层中，然后多种武器的动画，一种武器就是一个子动画蓝图。

CharacterMovementComponent 拓展

CharacterMovementComponent 组件主要就是实现了网络状态下的移动同步，我主要拓展的点是在移动过程中有各种的 MoveMode 在天空就是 Falling ，在地面就是 Walking。然后我加了一个状态 Sliding （滑铲）。并实现网络同步。

滑铲的逻辑多个客户端

触发逻辑是和原本的 Jump 逻辑一样，本地按下c键，判断是否可以进入滑铲状态（速度足够）更新bPressSlide 这个bool 值，然后在 `CharacterMovementComponent`的Tick 就是 update 去CheckInput 如果有就更新 bWasSlideing 并更新 

* 本地客户端（自主代理） 向 Sever 进行同步

是继承SaveMove_Character 以及重写一系列函数。考虑带宽，将bool 压缩成一个 bit 位。最后以 Sever RPC 的形式发往服务器，然后服务器那边解压缩。

* 服务器到模拟端的同步

通过 ReplicatedMovement 这个 uint8 类型 replicated 到模拟端

// 具体的滑铲更新逻辑主要是重写 physcutom 稍微有点多如果您想听我就说

● 根据坡度进行进行速度更新，如果上坡滑铲距离会很短，速度也会更低，在下坡的时候大于 20 度可以一直进行滑铲，随着坡度的增加，速度增加。

● 记录上一帧的方向与当前帧的方向，根据方向来更新当前速度。

● 在 IsWalkableFloor( ) 函数没有检测到脚下物体然后 ResetSlideState 重置Slide 状态。

**子弹同步**



![](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1Njc1NDU1MjExOA_177423_gVP6PFO3FIF6QL31_1718953645?imageMogr2/thumbnail/1600x%3E/ignore-error/1)

子弹校验逻辑

子弹在客户端命中之后会向服务器发送一个 ShootPackage 做判断包括击中者被击中者的信息，子弹发射时间，射击的校验信息。

![](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1Njc1NDU1MjExOA_276458_Z_4OfOa1ZBGAO96m_1719210274?imageMogr2/thumbnail/1600x%3E/ignore-error/1)

首先在服务器上做一个距离检测，判断当前人物与被击中时的距离，如果很大直接丢弃，如果很小相信，处于中间的话去将对方的位置回滚去用射线检测做具体的模拟。

回滚的时间 = 射击命中包的时间 + 客户端平滑表现时间

然后在此基础上再回滚一次// 回滚的时间 = 射击命中包的时间去做掩体判断

![](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1Njc1NDU1MjExOA_565448_LPyAsIbCTaLTu35Q_1719296420?imageMogr2/thumbnail/1600x%3E/ignore-error/1)



### 游戏引擎知识：

#### 渲染章节

* [硬件显卡](https://mp.weixin.qq.com/s/nJJiKgpK8hUfCqVNRhN1JQ)

* [渲染场景](https://mp.weixin.qq.com/s/_cLPPWB40n_dgNsy5tGGzA)

* [渲染系统](https://mp.weixin.qq.com/s/NmuYf0CwvhcSEQPJdfhV3w)

* [核心渲染算法_01](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247484461&idx=1&sn=fecec2f7b492c11584c2efed7bb884de&chksm=c04f3c4af738b55ce8063692aa9acaab384949cf05116972595f9fa44b5f8902bdde0bcbd93d&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [核心渲染算法_02](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247484683&idx=1&sn=196d6076fe8641f0554a45f27b01f808&chksm=c04f3d6cf738b47ab07f13ef7e1fec55b17bb425edba87b0d22643fbeeaba8749e6c7bbac99b&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [核心渲染算法_03](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247484744&idx=1&sn=9416dea0c872ce533010375055ad7e92&chksm=c04f3d2ff738b439b1b0de939a969ea85ba151028dec5b6b8266b42f373f94f5bc23a35d78f7&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [核心渲染算法——PBR](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247484751&idx=1&sn=e57d8c23b7e053fb755b5c21198f0ae5&chksm=c04f3d28f738b43ea94ff72c72cdc57e300577f29162386c5b8be6ea239bdbbac377e58075c8&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [渲染算法—光照与阴影](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247484786&idx=1&sn=9e8d27e04a2361a3bcc8b18b2e8fd90a&chksm=c04f3d15f738b403cf4da0ba0f32155317a40a058f218e928adc768d673326cb1b1207468ad0&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [Lumen 全局光照_01](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485118&idx=1&sn=5370a3576ceb01aa2543857194607f7b&chksm=c04f3ed9f738b7cfae7e2ceb0d99889a4a0b2364ea57c205ad490aa3e1132fa3c9458f5be8c9&cur_album_id=2583276961356152834&scene=189#wechat_redirect) [Lumen 全局光照_02](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485142&idx=1&sn=626b0089d2bbe9f9bccda0b4dc174709&chksm=c04f3eb1f738b7a768af005bca4a2930a83574ba1145f4d8bb9e1385e8f95c3cf35cb5bf9195&cur_album_id=2583276961356152834&scene=189#wechat_redirect) [Lumen_本身介绍](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485191&idx=1&sn=c9da76a454335a0e14d2739b54df07f7&chksm=c04f3f60f738b676aeba1ecb9605cda36f17193c4278052f73943ad499dc577634e1511aa33d&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [环境光遮蔽](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485592&idx=1&sn=20908796cb541cdc162d473b4c7ff3b5&chksm=c04f30fff738b9e90489346f832df76aa50e8ef40732a2884338de064f97ad280aba185d7b54&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [后处理](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485740&idx=1&sn=3d6e7dd2be780d85fd75f06df894d9bb&chksm=c04f314bf738b85d087208d23941c9fa366e2f71c2f0f5bc9771c5ef0087968a624d8a6b9e14&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [现代渲染管线发展](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485745&idx=1&sn=598a56b3f0325423fcfc220e622666b9&chksm=c04f3156f738b84013a1aa0690ac27d8b91b8a1b426b5aa4ce2bbeeeb3a652f4d9e0987e475b&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

#### 动画技术

* [动画技术前世今生](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485737&idx=1&sn=a93b161a523001f4ae423855ddabf3a5&chksm=c04f314ef738b858dfc413bf2368dd02462a83758bb8f377bc17d8be905c8f5bd38be5fc626f&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [蒙皮](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485943&idx=1&sn=578e3a09dd434dfef7a31469c3b2a7e8&chksm=c04f3190f738b886bdec69aecbd6fe0bbb4b32ef403938b2ea69a18e735e2ceacc4b2d2a044c&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [GPU 动画](https://blog.csdn.net/final5788/article/details/135219200)

#### AI 与 寻路

* [Navmesh](https://www.yisu.com/jc/563567.html)
* [HTN 介绍](https://www.baidu.com/link?url=ySstZjbIsLZ4B66rXRbS0aSZSOlEPQPbL6rO1HR6FXSMECrRezVV3QhXOy8NwO0a2yqaKsw0yAuJF-ULRLLXp4RreuYnudpqYlMKwI_FBse&wd=&eqid=eb0f16d10016be96000000036613409e)

#### 物理系统

#### Nanite

Nanite，基于CusterBase（去做裁剪，剔除），根据LOD 去构建了BVH，Cluster Group加速结构。方便根据屏幕信息，去选择合适的LOD更新到GPU 显存。对Cluster 按材质排序进行归类渲染。使用Visibilty 去优化延迟渲染的G-Buffer 的over Draw。然后用 virture Texture，去做 virture shadow map(以视角空间中的)。

#### Lumen

使用SDF 优化光线与三角形求交，快速求解直接光。使用Surface Cahe(表面缓存)也就是虚拟纹理存储直接光照信息法线，漫反射等信息。Lumen 最多只能产生一次反弹的间接光。复用上一帧的表面缓存光照信息。

Lumen 从近到远使用的是：SSGI，SDF RayTracing，SVOGI，立方体映射。

## C++

* [GitHub - huihut/interview: 📚 C/C++ 技术面试基础知识总结](https://github.com/huihut/interview?tab=readme-ov-file#cc)

* 个人技术文章总结

* [内存](https://blog.csdn.net/qq_63051355/article/details/127579602)

* [四万字模版总结](https://zhuanlan.zhihu.com/p/672410503)

#### STL

* [优先队列](https://blog.csdn.net/weixin_62985813/article/details/133900648)
* 

## Unity

[风哥文档](https://www.yuque.com/chengxuyuanchangfeng/qxodkp/gpopm7tvtalzwkvx)

#### UI

* [UI合批规则](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq826364410/article/details/80983861)  [UI合批示例@](https://zhuanlan.zhihu.com/p/478753600)
* https://www.jianshu.com/p/8139bacb2991

#### GC

* [Unity GC](https://www.zhihu.com/question/23790314/answer/3493826128)

## 操作系统

* [图解系统介绍 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/os/#%E5%B0%8F%E7%99%BD%E9%80%82%E5%90%88%E7%9C%8B%E5%90%97)

* [CSAPP 笔记](https://hansimov.gitbook.io/csapp/part2/ch09-virtual-memory/9.8-memory-mapping)

* https://zhuanlan.zhihu.com/p/677097212?utm_campaign=&utm_medium=social&utm_psn=1762045000182231040&utm_source=qq

## 编译原理

* 编译语言与解释语言的区别

## 额外知识的补充：

* [ECS 架构](https://blog.csdn.net/qq_43413788/article/details/129541074)

* [游戏引擎的JobSystem](https://mp.weixin.qq.com/s?__biz=Mzg5OTc1NjI5Ng==&mid=2247485483&idx=1&sn=085b81651fec353b9f6ffc40e8b0184f&chksm=c04f304cf738b95a47f54cc329e21c1518cf379c1df2585c2af1e48cc55ba0ae34d275bc2de9&cur_album_id=2583276961356152834&scene=189#wechat_redirect)

* [MVC 模式](https://c.biancheng.net/spring_mvc/9666.html?eqid=ff25e9b500205b800000000464564e5c)

## 手撕环节

* 手撕一个Unity 中的单例，C++ 中的单例模式

```C++
class SingletonExample{
private:
    static SingletonExample *_instance;
    void init(){
        // .. 初始化
    }
public:
    static SingletonExample& GetInstance(){
        if(_instance == nullptr){
            _instance = new SingletonExample();
            _instance->init();
        }
        return *_instance;
    }
};


template<class T>
class Singleton{
private:
    static T *_instance;
    void init(){
        // .. 初始化
    }
public:
    static SingletonExample& GetInstance(){
        if(_instance == nullptr){
            _instance = new T();
            _instance->init();
        }
        return *_instance;
    }
};
```

* Unity 中的模版单例
* 手撕Strings 类

```C++
class Strings{
private:
    char* data;
    size_t len;

    void copy_data(const char* s,size_t lens) {
        data = new char[lens + 1];
        memcpy(data, s, lens);
        data[lens] = '\0';
    }
public:
    // 构造函数
    Strings():data(nullptr),len(0){}

    Strings(const char * other){
        len = strlen(other);
        copy_data(other,len);
    }

    // 移动构造
    Strings(Strings&& other) noexcept {
        len = other.len;
        data = other.data;
        other.data = nullptr;
    }

    // 拷贝构造
    Strings(const Strings& other){
        len = other.len;
        copy_data(other.data,len);
    }

    // 复制赋值操作符
    Strings& operator=(const Strings& other) {
        if (this != &other) {
            delete[] data;
            len = other.len;
            copy_data(other.data,len);
        }
        return *this;
    }

    // 移动赋值操作符
    Strings& operator=(Strings&& other) noexcept {
        if (this != &other) {
            data = other.data;
            len = other.len;
            other.data = nullptr;
            other.len = 0;
        }
        return *this;
    }

    ~Strings(){
        delete[] data;
    }

    size_t size(){
        return len;
    }
};
```
