## 数据结构

1. 大量数据的排序（全服所有玩家按照积分排序，在线的在前，离线的在后）

2. 基于物体/空间的空间划分（BVH、kd树）

3. 大量数据取最小值（小顶堆）

## 图形学

1. 切线空间
   
   切线坐标系规定x轴是由切线方向和y轴是副切线坐标构成的，垂直于这个平面的就叫做法线。

2. 光照探针

3. 如何优化msaa，延迟渲染如何使用msaa
   
   **四倍大小的 G-buffer** 

4. 了解PBR吗

5. lambert材质的BRDF是ρ/pi，为什么要除这个pi呢。
   
   在光照计算中，我们通常假设一个完全漫反射的表面在所有方向上总共反射入射光的100%，这就需要在计算过程中引入一个归一化因子。在半球空间内均匀分布的光源的总亮度是π，因此我们需要用π来进行归一化,能量守恒。

6. 欧拉角和四元数如何转换，四元数的优势和劣势

7. ndc是什么，坐标范围？
   
   NDC是一个中间坐标系统，用于将3D世界或模型坐标转换为2D屏幕坐标。在进行渲染之前，所有的3D坐标都会被转换为NDC，然后再进一步转换为屏幕坐标。在OpenGL中，Z轴的范围是-1到1，但在DirectX中，Z轴的范围是0到1。

8. .IBL的实现细节，diffuse和specular部分分别是怎么做的？IBL的specular部分的卷积，做了什么假设？这样假设会出现什么问题？
   
   **Diffuse IBL**
   
   漫反射IBL的核心思想是，一个点的漫反射光照可以通过对环境贴图进行积分来模拟，在实践中，这个积分过程在渲染之前就已经完成了
   
   **Specular IBL**
   
   镜面反射IBL需要考虑微表面模型，即表面上的微小凹凸对光照的影响。原始环境贴图会生成一系列的Mipmap层级，每个层级对应一个模糊程度。使用导向反射函数（BRDF）通常用采样预先计算的2D LUT（查找表）来实现（表中存储了不同视角和粗糙度下的反射率）来实现。
   
   **实时渲染时的采样**：在渲染时，根据粗糙度和反射向量从Mipmap中选择合适的层级进行采样。这会得到一张包含了不同粗糙度下反射光照信息的纹理。然后结合BRDF LUT和这个纹理，来确定表面的最终镜面反射颜色。

9. 

10. 23

## 图形Api

## C++

1. this的原理，存在哪里，this放在哪里可以更好地管理它

2. 函数调用时的内存如何开辟

3. C++内存模型（如何设计类的内存模型让类型转换更高效，脚本语言慢在哪儿了，静态编译语言又快在哪儿了）

4. 讲讲几种智能指针，追问unique实现，unique有计数吗

5. 说说std::move和std::forward，追问是否有性能开销？追问move的应用场景
   
   `std::move` 将其参数转换为右值引用，从而允许对象的资源被“移动”而非复制。它本质上是一个类型转换操作，`std::move` 本身几乎没有性能开销，它仅进行类型的转换。`forward`也是如此

6. lambda了解过吗，底层实现？（实际上是仿函数）
   
   在底层，ambda表达式都等价于一个未命名的函数对象的实例。编译器会为每个lambda表达式生成一个唯一的类（称为闭包类型），这个类重载了`operator()`，使得这个类的实例可以像函数一样被调用。

7. 函数调用时的内存如何开辟
   
   当一个函数被调用时，操作系统为它的执行在内存中开辟一个栈帧（Stack Frame），保存寄存器值，保存返回地址，压入参数。

8. 