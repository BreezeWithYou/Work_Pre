## 2024 搜狐畅游U3D

![image-20240329180024921](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329180024921.png)

![image-20240329180058480](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329180058480.png)

12、为了优化SetPass Call高,哪个优化手段是错误的

**简单的理解 SetPassCall ：**调用DrawCall之前，在绘制此 Pass 前，需要设置的所有渲染状态配置、或是BUFFER设置，都算是 SetPassCall 的内容。，Shader 属于

23、

在Unity3D游戏引擎中，`MeshRenderer`组件的`material`和`sharedMaterial`属性用来访问和修改游戏对象的材质。下面是对选项的解释：

A. 使用过程推荐修改由sharedMaterial返回的材质 这个陈述是错误的。`sharedMaterial`属性用来访问共享材质，修改它会影响所有使用该共享材质的对象。通常不推荐在运行时修改`sharedMaterial`，因为这样做会影响所有使用这个材质的渲染器。

B. 想修改渲染器的材质，使用material,也改变了储存在工程里的材质设置 这个陈述是错误的。访问`material`属性会创建材质的一个副本（如果材质被多个渲染器共享的话），这样修改不会影响其他渲染器或工程中存储的原始材质。但是，需要注意的是，这种做法在性能上可能有开销，因为它可能会导致运行时生成新的材质实例。

D. 修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。 这个陈述是对的。

25

**删除组件**：为了删除一个组件，你应该使用`Destroy()`函数而不是`RemoveComponent<T>()`。你需要传递想要删除的组件的引用给`Destroy()`函数。例如，如果你想要删除游戏对象上的`Rigidbody`组件，你可以使用`Destroy(gameObject.GetComponent<Rigidbody>());`。

## 网易

## 2024 4399

![image-20240329182859965](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329182859965.png)

## 快手

![image-20240329184042265](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329184042265.png)

![image-20240329184054484](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329184054484.png)

![image-20240329184101291](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329184101291.png)

![image-20240329184123617](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329184123617.png)

![image-20240329184134891](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329184134891.png)

![image-20240329184216399](https://gitee.com/li-jiaqin-2022/pircture-all/raw/master/image-20240329184216399.png)
